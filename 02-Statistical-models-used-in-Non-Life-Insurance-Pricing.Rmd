---
output:
  bookdown::word_document2: default
  bookdown::pdf_document2:
    template: templates/brief_template.tex
  bookdown::html_document2: default
documentclass: book
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---

```{r echo=FALSE}
library(knitr)
```

<!-- <!-- Needed for leaving space to the quote, * is for no indentation after title --> -->

<!-- \titlespacing*{\chapter}{0pt}{80px}{35pt} -->

# **Statistical models for Non Life Insurance Pricing** {#chap:models}
\minitoc  <!--this will include a mini table of contents-->

\chaptermark{Statistical models for Non Life Insurance Pricing}

In this chapter we are going to illustrate some of the most widespread models for technical pricing. For each model we are going to describe its benefits and drawbacks and in section \@ref(chap:actuary-importance) we will compare them by discussing how they fit the pricing needs.


## Statistical Models

In this section we will start by describing the Generalized Linear Model (GLM), that is the most employed model in technical pricing, to then present some of its advancements: the Elastic Net and the Generalized Additive Model (GAM). After this description, we will also present the Gradient Boosting Machine (GBM), that is one of the most effective general purpose machine learning models. This allows us to have a comparison between GLM based models and general purpose machine learning models.


### GLM


#### Linear Exponential Families {#chap:linear-exp-families}

One of the GLM assumptions is that the response variables belong to a _Linear Exponential Family_. In this section we are going to explain what a linear exponential family is and which distributions fit its definition.

```{definition, linear-exp-family, name = "Linear Exponential Family"}
A Linear Exponential Family $\mathcal{F}$ is a parametrical family of probability distributions with density function (or probability function in the discrete case) that can be expressed in the form:
$$
f(y; \theta, \lambda) = \exp{\left\{ \frac{y\theta-b(\theta)}{\lambda} \right\}} c(y,\lambda), \quad y\in \mathcal{Y}\subseteq\mathbb{R}
$$
where:

\begin{itemize}
\item $\theta\in\Theta\subseteq\mathbb{R}$ is called \textit{canonical parameter};
\item $\lambda\in\Lambda\subseteq]0, +\infty[$ is called \textit{dispersion parameter};
\item $b: \Theta \rightarrow \mathbb{R}$ is a real function called \textit{cumulant function};
\item $c: (\mathcal{Y}, \Lambda) \rightarrow [0, +\infty[$ is a real function;
\item $\Theta$ is a non degenerate interval, i.e. $\text{int}\Theta$ is not empty.
\end{itemize}

```

An exponential family $\mathcal{F}$ is characterized by the elements $\left( \Theta, b(\cdot), \Lambda, c(\cdot, \cdot) \right)$. By properly choosing the sets $\Theta, \Lambda$ and the functions $b(\cdot), c(\cdot, \cdot)$, it is possible to obtain many useful families.

It can be easily shown that the families Normal, Poisson, Gamma and Binomial are exponential families. In table \@ref(tab:exp-families) the characterizations for these exponential families are reported.

```{r, exp-families-table, echo = FALSE, cache = TRUE}

table <- tibble(
  Distribution = linebreak(c("Normal", "Poisson", "Gamma", "Scaled\nBinomial"),
                           align = "l"),
  # Notation = linebreak(c("$N(\\mu, \\sigma^2)$,\n$\\mu\\in\\mathbb{R}, \\ \\sigma \\in ]0, +\\infty[$",
  #                        "$Poisson(\\mu)$,\n$\\mu \\in ]0, +\\infty[$",
  #                        "$Gamma(\\alpha, \\mu)$,\n$\\alpha \\in ]0, +\\infty[, \\ \\mu \\in ]0, +\\infty[$",
  #                        "$Binom(n, p)/n$,\n$n\\in\\mathbb{N}, \\ p\\in]0,1[$"),
  #                      align = "c"),
  Notation = linebreak(c("$N(\\mu, \\sigma^2)$,\n$\\mu\\in\\mathbb{R}$ \n $\\sigma \\in ]0, +\\infty[$",
                         "$Poisson(\\mu)$,\n$\\mu \\in ]0, +\\infty[$",
                         "$Gamma(\\alpha, \\mu)$,\n$\\alpha \\in ]0, +\\infty[$ \n $\\mu \\in ]0, +\\infty[$",
                         "$Binom(n, p)/n$,\n$n\\in\\mathbb{N}$ \n $p\\in]0,1[$"),
                       align = "c"),
  `$\\Theta$` = c("$\\mathbb{R}$",
                  "$\\mathbb{R}$",
                  "$]-\\infty, 0[$",
                  "$\\mathbb{R}$"),
  `$\\theta$` = c("$\\mu$",
                  "$\\log{(\\mu)}$",
                  "$-\\frac{1}{\\mu}$",
                  "$\\log{\\left(\\frac{p}{1-p}\\right)}$"),
  `$\\Lambda$` = c("$]0, +\\infty[$",
                  "$\\left\\{1\\right\\}$",
                  "$]0,+\\infty[$",
                  "$\\left\\{\\frac{1}{n}\\right\\}$"),
  `$\\lambda$` = c("$\\sigma^2$",
                  "$1$",
                  "$\\frac{1}{\\alpha}$",
                  "$\\frac{1}{n}$"),
  `$b(\\theta)$` = c("$\\frac{\\theta^2}{2}$",
                  "$e^{\\theta}$",
                  "$-\\log{\\left(-\\theta\\right)}$",
                  "$\\log\\left(1+e^{\\theta}\\right)$"),
)


# For compatibility with HTML
if(!knitr::is_latex_output()){
  
  table <- table %>% 
    mutate(
      Distribution = Distribution %>% 
        str_replace_all("\\\\makecell\\[[lrc]\\]\\{(.*)\\}", "\\1") %>% 
        str_replace_all("\\\\\\\\", "<br>"),
      Notation = Notation %>% 
        str_replace_all("\\\\makecell\\[[lrc]\\]\\{(.*)\\}", "\\1") %>% 
        str_replace_all("\\\\\\\\", "<br>"),
    )
  
  names(table) <- names(table) %>% 
    str_replace_all("\\\\makecell\\[[lrc]\\]\\{(.*)\\}", "\\1") %>% 
    str_replace_all("\\\\\\\\", "<br>")
}


table %>% 
  kable(
    # format = "latex",
    booktabs = T,
    align = "lcccccc",
    vline = "",
    toprule = "\\toprule", midrule = "\\toprule\\addlinespace",
    linesep = "\\addlinespace\\hline\\addlinespace", bottomrule = "\\bottomrule",
    caption = "Some Linear Exponential Families.",
    label = "exp-families",
    escape = FALSE
  ) %>% 
  kable_styling(
    position = "center",
    latex_options = "hold_position",
    full_width = FALSE
  ) %>% 
  row_spec(ifelse(!knitr::is_latex_output(), 0, 1), bold = T)
  
```

The distributions that belong to an exponential family have many useful properties. For example they are provided with all the moments and their moments can be obtained using the derivatives of the cumulative function $b(\cdot)$. If $Y$ is a random variable with distribution belonging to an exponential family $\mathcal{F}$ with parameters $\theta, \lambda$, its first two moments are:
\begin{align}
\label{eq:exp-fam-expected-value}
E(Y)   & = b'(\theta) \\
Var(Y) & = \lambda b''(\theta)
\end{align}

As, within a specified family, the parameters $\theta$ and $\lambda$ determine a distribution, in practical problems the object of estimation will be the couple $(\theta, \lambda)$. In many problems it is natural to consider distributions from a linear exponential family where the dispersion parameter can be expressed as $\lambda = \frac{\phi}{\omega}$, where $\omega>0$ is a known _weight_ and $\phi>0$ is a parameter that we will keep calling _dispersion parameter_. In this case, the density of probability function depends on the parameters $\theta$ and $\phi$ and will be expressed as:
$$
f(y; \theta, \phi, \omega) = \exp{\left\{ \frac{\omega}{\phi} \left[y\theta - b(\theta) \right] \right\}} c(y, \phi, \omega), \quad y\in \mathcal{Y}\subseteq\mathbb{R}
$$

In this case the parameters $\theta$ and $\phi$ will be object of estimation, while $\omega$ is an already known value. As we will see later, this representation allows us to consider as known weights:

* the exposure $v$ in the Poisson distribution;
* the number of trials $n$ in the Binomial distribution.



#### Model assumptions {#chap:glm-assumptions}

Let's assume that, for $n$ statistical units, the observations $\mathcal{D} = \left\{ (\boldsymbol{x}_1, \omega_1, y_1), \dots,  (\boldsymbol{x}_n, \omega_n, y_n) \right\}$ are available, where $\boldsymbol{x}_i$ is a vector of explanatory variables determinations, $\omega_i$ is a known weight and $y_i$ is the response variable determination. $\boldsymbol{x}_i, \omega_i, y_i$ are all real numbers. The vector $\boldsymbol{y} = (y_1, \dots, y_n)^t$ is considered a determination of the response random vector $\boldsymbol{Y} = (Y_1, \dots, Y_n)^t$.

In GLM we assume that:

1. The response variables $Y_1, \dots, Y_n$ are stochastically independent and with probability distribution belonging to a same linear exponential family; i.e. the probability distribution of $Y_i$ has density function (or probability function in the discrete case) that can be expressed as:
$$
f(y_i; \theta_i, \phi, \omega_i) = \exp{\left\{ \frac{\omega_i}{\phi} \left[y_i\theta_i - b(\theta_i) \right] \right\}} c(y_i, \phi, \omega_i), \quad y_i\in \mathcal{Y}\subseteq\mathbb{R}
$$
We highlight that only $\theta_i$ and $\omega_i$ depend on $i$, while the dispersion parameter $\phi$ is the same for all the observations.
2. The explanatory variables determinations vector $\boldsymbol{x}_i = \left(1, x_{i1}, \dots, x_{ip} \right)^t$ affects the probability distribution of the response variable $Y_i$ by the linear predictor:
$$
\eta_i = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \dots + \beta_p x_{ip}
$$
that is a linear function of the regression parameters $\boldsymbol{\beta} = \left( \beta_0, \beta_1, \dots, \beta_p \right)$.
3. The linear predictor $\eta_i$ is linked to the expected value of the response variable $\mu_i = E(Y_i)$ by the following relation:
$$
g(\mu_i) = \eta_i = \boldsymbol{x}_i^t \boldsymbol{\beta}
$$
where $g:\mathbb{R}\rightarrow\mathbb{R}$ is a monotonic function with continuous first and second derivatives. $g(\cdot)$ is called _link function_.

Often, the assumption 1 is called stochastic assumption, while the 2 and 3 are called structural assumptions.

Let's indicate with $\boldsymbol{X}$ the design matrix, i.e. the matrix in which each row $\boldsymbol{x}_{i\cdot}$ represents the vector of the explanatory variables for the observation $i$ and each column $\boldsymbol{x}_{\cdot j}$ represents the vector of the observations for the explanatory variable $j$. The design matrix is represented in figure \@ref(fig:design-matrix). The matrix starts with a column of 1s, that is used to model the intercept. Thus, it is a matrix $n\times(p+1)$. We assume, as it is common in actuarial datasets, that $n>p+1$.


```{tikz, design-matrix, fig.cap = "Design Matrix $\\boldsymbol{X}$.", fig.ext = 'pdf', cache = TRUE, echo = FALSE, fig.align = 'center'}
\usetikzlibrary{arrows.meta, bending, matrix, positioning}
\pgfdeclarelayer{bg}    % declare background layer
\pgfsetlayers{bg,main}  % set the order of the layers (main is the standard layer)
%\usepackage{xcolor}
\definecolor{col1}{HTML}{F8766D}
\definecolor{col2}{HTML}{00BFC4}

\begin{center}
\begin{tikzpicture}[node distance = 1mm and 0mm, baseline]

% Draw matrix
\matrix (M1) [matrix of nodes,{left delimiter=[},{right delimiter=]}]
{
    $1$      & $x_{11}$ & $\dots$  & $x_{1j}$ & $\dots$  & $x_{1p}$ \\
    $1$      & $x_{21}$ & $\dots$  & $x_{2j}$ & $\dots$  & $x_{2p}$ \\
    $\vdots$ & $\vdots$ & $\ddots$ & $\vdots$ & $\ddots$ & $\vdots$ \\
    $1$      & $x_{i1}$ & $\dots$  & $x_{ij}$ & $\dots$  & $x_{ip}$ \\
    $\vdots$ & $\vdots$ & $\ddots$ & $\vdots$ & $\ddots$ & $\vdots$ \\
    $1$      & $x_{n1}$ & $\dots$  & $x_{nj}$ & $\dots$  & $x_{np}$ \\
};

% Draw red vertical rectangle
\begin{pgfonlayer}{bg}    % select the background layer
%\draw[red!60, very thick, fill = red!60, fill opacity = 0.2] 
%        (M1-1-4.north west) -| (M1-6-4.south east) -| (M1-1-4.north west);
\draw[col1, very thick, fill = col1, fill opacity = 0.2] 
        (M1-1-4.north west) -| (M1-6-4.south east) -| (M1-1-4.north west);
\end{pgfonlayer}
\node (ev) [below = 1cm of M1-6-4.south, align = center] {$\boldsymbol{x}_{\cdot j}$\\explanatory\\variable $j$};
\draw[col1, very thick,shorten >=1mm, -{Stealth[bend]}] 
        (ev.north) to (M1-6-4.south);

% Draw blue horizontal rectangle
\begin{pgfonlayer}{bg}    % select the background layer
%\draw[blue!60, very thick, fill = blue!60, fill opacity = 0.2]
%        (M1-4-1.north west) -| (M1-4-6.south east) -| (M1-4-1.north west);
\draw[col2, very thick, fill = col2, fill opacity = 0.2]
        (M1-4-1.north west) -| (M1-4-6.south east) -| (M1-4-1.north west);
\end{pgfonlayer}
\node (obs) [right = 1cm of M1-4-6.east, align = center] {$\boldsymbol{x}_{i\cdot}$\\observation $i$};
\draw[col2, very thick,shorten >=1mm, -{Stealth[bend]}] 
        (obs.west) to (M1-4-6.east);

\end{tikzpicture}
\end{center}

```


We can then express the GLM structural assumptions in a matrix form as:
$$
\boldsymbol{g}(\boldsymbol{\mu}) = \boldsymbol{X} \boldsymbol{\beta}
$$
where $\boldsymbol{g}(\cdot)$ must be intended as the vectorial function that links every $\mu_i$ to $g(\mu_i)$.
$$
\begin{array}{cccc}
\boldsymbol{g}: & \mathbb{R}^n & \longrightarrow & \mathbb{R}^n \\
                & \left(
                    \begin{matrix} \mu_1  \\ \vdots \\ \mu_n \end{matrix}
                  \right)
                  & \longmapsto & 
                  \left(
                    \begin{matrix} g(\mu_1)  \\ \vdots \\ g(\mu_n) \end{matrix}
                  \right)
\end{array}
$$

We assume the design matrix to be a full rank matrix, i.e. $\text{rank}(\boldsymbol{X}) = p+1$. This assumption corresponds to assuming that the columns of $\boldsymbol{X}$ are linearly independent.

The function $g(\cdot)$ can be chosen as any monotonic function with continuous first and second derivatives. Given a family $\mathcal{F}$, a common choice is its canonical link function that is defined as:
$$
g(\mu) = b'^{-1}(\mu)
$$
From \@ref(eq:exp-fam-expected-value) we obtain that, as $\mu = b'(\theta)$, choosing the canonical function corresponds to using $\theta$ as the linear predictor:
$$
\eta = g(\mu) = b'^{-1}(\mu) = \theta
$$

In table \@ref(tab:can-link-fun) the canonical link functions for the families mentioned in \@ref(tab:exp-families) are reported.

```{r, can-link-fun, echo = FALSE, cache = TRUE}
table <- tibble(
  Distribution = linebreak(c("Normal", "Poisson", "Gamma", "Scaled\nBinomial"),
                           align = "l"),
  `\\makecell[c]{Cumulant function\\\\$b(\\theta)$}` = c("$\\frac{\\theta^2}{2}$",
                     "$e^{\\theta}$",
                     "$-\\log{\\left(-\\theta\\right)}$",
                     "$\\log\\left(1+e^{\\theta}\\right)$"),
  `\\makecell[c]{Derivative\\\\$b'(\\theta)$}` = c("$\\theta$",
                      "$e^\\theta$",
                      "$-\\frac{1}{\\theta}$",
                      "$\\frac{e^{\\theta}}{1 + e^{\\theta}}$"),
  `\\makecell[c]{Canonical link function\\\\$g(\\mu)=b'^{-1}(\\mu)$}` = c("$\\mu$",
                                  "$\\log{(\\mu)}$",
                                  "$-\\frac{1}{\\mu}$",
                                  "$\\log{\\left( \\frac{p}{1-p} \\right)}$"),
)

# For compatibility with HTML
if(!knitr::is_latex_output()){
  
  table <- table %>% 
    mutate(
      Distribution = Distribution %>% 
        str_replace_all("\\\\makecell\\[[lrc]\\]\\{(.*)\\}", "\\1") %>% 
        str_replace_all("\\\\\\\\", "<br>")
    )
  
  names(table) <- names(table) %>% 
    str_replace_all("\\\\makecell\\[[lrc]\\]\\{(.*)\\}", "\\1") %>% 
    str_replace_all("\\\\\\\\", "<br>")
}

table %>% 
  kable(
    # format = "latex",
    booktabs = T,
    align = "lccc",
    vline = "",
    toprule = "\\toprule", midrule = "\\toprule\\addlinespace",
    linesep = "\\addlinespace\\hline\\addlinespace", bottomrule = "\\bottomrule",
    caption = "Canonical link functions.",
    label = "can-link-fun",
    escape = FALSE
  ) %>% 
  kable_styling(
    position = "center",
    latex_options = "hold_position",
    full_width = FALSE
  ) %>% 
  row_spec(ifelse(!knitr::is_latex_output(), 0, 1), bold = T)
```

In the Gamma case, its canonical function $g(\mu)=-\frac{1}{\mu}$ has the drawback that it links the expected values $\mu\in]0,+\infty[$ to $\eta\in]-\infty, 0[$. This would require some constraints on $\boldsymbol{\beta}$ because $\eta=\boldsymbol{x}^t\boldsymbol{\beta}$ would have to be $<0$. For this reason, it is preferred to use $g(\mu) = \log(\mu)$ that maps $]0, +\infty[$ to $\mathbb{R}$.

In the Scaled Binomial case the canonical function $g(p) = \log{\left(\frac{p}{1-p}\right)}$ is called logit and its inverse $g^{-1}(\eta) = \frac{e^{\eta}}{1 + e^{\eta}}$ is called logistic. For Scaled Binomial distribution we keep using the notation $p$ for the expected value as it corresponds to the probability of success $p$.


#### Model fitting

The model depends on the parameters $\left(\boldsymbol{\beta}, \phi\right)$. Indeed, the parameters $\theta_i$ can be obtained by $\boldsymbol{\beta}$ as:
$$
\theta_i = b'^{-1}(\mu_i) = b'^{-1}(g^{-1}(\eta_i)) = b'^{-1}\left(g^{-1}\left(\boldsymbol{x}_i^t\boldsymbol{\beta}\right)\right)
$$

Therefore, fitting the model corresponds to estimating $\left(\boldsymbol{\beta}, \phi\right)$. The technique used in GLM is the _maximum likelihood_. Let's indicate with $L\left(\boldsymbol{\beta}, \phi; \boldsymbol{y}\right)$ the model likelihood. We remind that the likelihood is a function of the parameters that maps $\left(\boldsymbol{\beta}, \phi\right)$ to the density (or probability in the discrete case) of the observed values $\boldsymbol{y}$ conditioned to the parameters $\left(\boldsymbol{\beta}, \phi\right)$
$$
\begin{array}{cccc}
L: & \mathbb{R}^{p+1} \times \Lambda & \longrightarrow & [0, +\infty[ \\
   & \left(\boldsymbol{\beta}, \phi\right) & \longmapsto & f_{\boldsymbol{Y}}(\boldsymbol{y}; \boldsymbol{\theta}, \phi)
\end{array}
$$

The maximum likelihood estimates are the values $\left(\boldsymbol{\beta}, \phi\right)$ that maximize $L\left(\boldsymbol{\beta}, \phi; \boldsymbol{y}\right)$. In practice, $\boldsymbol{\beta}$ are the parameters of interest, while $\phi$ is considered as a disturbance parameter. It is possible to show that conditioned to any $\phi$, the value for $\boldsymbol{\beta}$ that maximizes $L(\cdot, \cdot)$ does not depend on $\phi$. Therefore, $\boldsymbol{\beta}$ and $\phi$ can be estimated separately.

Let's indicate with $\tilde{\boldsymbol{\beta}}$ the maximum likelihood estimator for $\boldsymbol{\beta}$. Its determination $\hat{\boldsymbol{\beta}}$ is defined as:
\begin{equation}
\label{eq:max-lik-est}
\hat{\boldsymbol{\beta}} = \argmax_{\boldsymbol{\beta}\in\mathbb{R}^{p+1}}{L\left(\boldsymbol{\beta}, \phi; \boldsymbol{y}\right)}
\end{equation}

Finding the values $\hat{\boldsymbol{\beta}}$ that maximize the likelihood corresponds to finding the values that maximize the log-likelihood $\ell\left(\boldsymbol{\beta}, \phi; \boldsymbol{y}\right) = \log{\left(L\left(\boldsymbol{\beta}, \phi; \boldsymbol{y}\right)\right)}$. For the independence hypothesis on $Y_1, \dots, Y_n$ we get:
\begin{align}
\nonumber
\ell\left(\boldsymbol{\beta}, \phi; \boldsymbol{y}\right) & =
\log{\left(L\left(\boldsymbol{\beta}, \phi; \boldsymbol{y}\right)\right)}
\\ \nonumber & =
\log{\left(\prod_{i=1}^{n}{\exp{\left\{ \frac{\omega_i}{\phi} \left[y_i\theta_i - b(\theta_i) \right] \right\}} c(y_i, \phi, \omega_i)}\right)}
\\ \label{eq:log-like} & =
\sum_{i=1}^{n}{
\left\{
\frac{\omega_i}{\phi} \left[y_i\theta_i - b(\theta_i) \right] + \log{\left(c(y_i, \phi, \omega_i)\right)}
\right\}
}
\\ \nonumber & =
\sum_{i=1}^{n}{\ell_i\left(\boldsymbol{\beta}, \phi; \boldsymbol{y}\right)}
\end{align}

The maximum value of $\ell\left(\boldsymbol{\beta}, \phi; \boldsymbol{y}\right)$ can be obtained by imposing all its partial derivatives equal to $0$:
$$
\frac{\partial \ell\left(\boldsymbol{\beta}, \phi; \boldsymbol{y}\right)}
{\partial\beta_j}
= 0, \quad \forall j\in\{0,1,\dots,p\}
$$

These equations can be solved with numerical methods, such as Newton-Raphson algorithm or its variant Fisher scoring. It is possible to show that Newton-Raphson algorithm corresponds to iteratively solving a weighted least squares optimization problem.

In the case with Normal response and identity link, the optimization problem \@ref(eq:max-lik-est) has an explicit solution:
$$
\hat{\boldsymbol{\beta}} = \left( \boldsymbol{X}^t \boldsymbol{X} \right)^{-1} \boldsymbol{X}^t \boldsymbol{y}
$$

A statistic that can be used to measure the goodness of fit of a model is the _Deviance_. It can be used by comparing the current model log-likelihood $\ell\left(\hat{\boldsymbol{\beta}}, \phi; \boldsymbol{y}\right)$ with the _saturated model_ log-likelihood $\ell_{S}\left(\boldsymbol{\beta}^*, \phi; \boldsymbol{y}\right)$. The saturated model is the model with $n$ parameters, so a model where the expected values of the response variables $\mu_1, \dots, \mu_n$ are estimated with their observed values $y_1, \dots, y_n$. It is possible to show that $\ell_{S}\left(\boldsymbol{\beta}^*, \phi; \boldsymbol{y}\right) \ge \ell\left(\hat{\boldsymbol{\beta}}, \phi; \boldsymbol{y}\right)$. The closer $\ell\left(\hat{\boldsymbol{\beta}}, \phi; \boldsymbol{y}\right)$ is to $\ell_{S}\left(\boldsymbol{\beta}^*, \phi; \boldsymbol{y}\right)$, the better the current model fitting is.

```{definition, deviance-def, name = "Deviance"}
Given $\ell\left(\hat{\boldsymbol{\beta}}, \phi; \boldsymbol{y}\right)$ the log-likelihood of the current model and $\ell_{S}\left(\boldsymbol{\beta}^*, \phi; \boldsymbol{y}\right)$ the log-likelihood of the saturated model, the \textit{Scaled Deviance} of the current model is defined as:
$$
S(\hat{\boldsymbol{\beta}}, \phi, \boldsymbol{y}) =
-2\left(
\ell\left(\hat{\boldsymbol{\beta}}, \phi; \boldsymbol{y}\right)
- \ell_{S}\left(\boldsymbol{\beta}^*, \phi; \boldsymbol{y}\right)
\right)
$$
The \textit{Deviance} of the current model is defined as:
$$
D(\hat{\boldsymbol{\beta}}, \boldsymbol{y}) =
\phi \, S(\hat{\boldsymbol{\beta}}, \phi, \boldsymbol{y})
$$

```

In deviance notation $D(\hat{\boldsymbol{\beta}}, \boldsymbol{y})$, the parameter $\phi$ is not reported because the deviance does not depend on $\phi$. Indeed, from \@ref(eq:log-like) we get:
\begin{align*}
S(\hat{\boldsymbol{\beta}}, \phi, \boldsymbol{y})
& =
-2\left(
\ell\left(\hat{\boldsymbol{\beta}}, \phi; \boldsymbol{y}\right)
- \ell_{S}\left(\boldsymbol{\beta}^*, \phi; \boldsymbol{y}\right)
\right)
\\ & =
-2\left(
\sum_{i=1}^{n}{
\left\{
\frac{\omega_i}{\phi} \left[y_i\hat{\theta}_i - b(\hat{\theta}_i) \right] + \log{\left(c(y_i, \phi, \omega_i)\right)}
\right\}
}
\right.
\\ & \qquad \qquad -
\left.
\sum_{i=1}^{n}{
\left\{
\frac{\omega_i}{\phi} \left[y_i\theta_i^* - b(\theta_i^*) \right] + \log{\left(c(y_i, \phi, \omega_i)\right)}
\right\}
}
\right)
\\ & =
-2\left(
\sum_{i=1}^{n}{
\frac{\omega_i}{\phi}
\left\{
\left[y_i\hat{\theta}_i - b(\hat{\theta}_i) \right]
- \left[y_i\theta_i^* - b(\theta_i^*) \right]
\right\}
}
\right)
%
\\[12pt]
%
D(\hat{\boldsymbol{\beta}}, \boldsymbol{y})
& =
-2\left(
\sum_{i=1}^{n}{
\omega_i
\left\{
\left[y_i\hat{\theta}_i - b(\hat{\theta}_i) \right]
- \left[y_i\theta_i^* - b(\theta_i^*) \right]
\right\}
}
\right)
\end{align*}

In table \@ref(tab:deviance) the deviances for the families mentioned in \@ref(tab:exp-families) are reported.

```{r, deviance-exp-fam, echo = FALSE, cache = TRUE}
table <- tibble(
  Distribution = linebreak(c("Normal", "Poisson", "Gamma", "Scaled\nBinomial"),
                           align = "l"),
  `Deviance $D(\\hat{\\boldsymbol{\\beta}}, \\boldsymbol{y})$` = c(
    "$\\sum_{i=1}^{n}{\\left( y_i - \\hat{\\mu}_i \\right)^2}$",
    "$2\\,\\sum_{i=1}^{n}{\\left\\{ y_i \\log{\\left(\\frac{y_i}{\\hat{\\mu}_i}\\right)} - \\left( y_i - \\hat{\\mu}_i \\right) \\right\\}}$",
    "$2\\,\\sum_{i=1}^{n}{\\left\\{ - \\log{\\left(\\frac{y_i}{\\hat{\\mu}_i}\\right)} + \\frac{ y_i - \\hat{\\mu}_i }{\\hat{\\mu}_i} \\right\\}}$",
    "$2\\,\\sum_{i=1}^{n}{\\left\\{ y_i \\log{\\left(\\frac{y_i}{\\hat{\\mu}_i}\\right)}+ \\left(1-y_i\\right) \\log{\\left(\\frac{1-y_i}{1-\\hat{\\mu}_i}\\right)} \\right\\}}$"
  ))

# For compatibility with HTML
if(!knitr::is_latex_output()){
  
  table <- table %>% 
    mutate(
      Distribution = Distribution %>% 
        str_replace_all("\\\\makecell\\[[lrc]\\]\\{(.*)\\}", "\\1") %>% 
        str_replace_all("\\\\\\\\", "<br>")
    )
  
  names(table) <- names(table) %>% 
    str_replace_all("\\\\makecell\\[[lrc]\\]\\{(.*)\\}", "\\1") %>% 
    str_replace_all("\\\\\\\\", "<br>")
}

table %>% 
  kable(
    # format = "latex",
    booktabs = T,
    align = "lc",
    vline = "",
    toprule = "\\toprule", midrule = "\\toprule\\addlinespace",
    linesep = "\\addlinespace\\hline\\addlinespace", bottomrule = "\\bottomrule",
    caption = "Deviance for Linear Exponential Families",
    label = "deviance",
    escape = FALSE
  ) %>% 
  kable_styling(
    position = "center",
    latex_options = "hold_position",
    full_width = FALSE
  ) %>% 
  row_spec(ifelse(!knitr::is_latex_output(), 0, 1), bold = T)
```

As $\ell_{S}\left(\boldsymbol{\beta}^*, \phi; \boldsymbol{y}\right)$ does not depend on $\hat{\boldsymbol{\beta}}$, maximizing the likelihood in equation \@ref(eq:max-lik-est) is the same as minimizing the deviance, that can be seen as a _Loss Function_:
\begin{equation}
\label{eq:max-lik-est-deviance}
\hat{\boldsymbol{\beta}} = \argmin_{\boldsymbol{\beta}\in\mathbb{R}^{p+1}}{D(\boldsymbol{\beta}, \boldsymbol{y})}
\end{equation}

<!--
* Maximum likelihood
* Iteratively reweighted least squares
  + Newton-Raphson, Fisher scoring
* Modello saturo
* Deviance
  + Loss function. Optimization process

-->




#### Variable effects {#chap:var-effects}

As we mentioned in \@ref(chap:pricing-variables-encoding), the explanatory variables can be _quantitative_ or _qualitative_. In GLM, if explanatory variables transformation terms aren't added to the linear predictor $\eta$, the variables effect on $\eta$ is linear. In figure \@ref(fig:expl-var-types) the effects of quantitative and qualitative variables are shown. The data is simulated from a GLM with Normal response and identity link.

(ref:expl-var-types-caption-latex) Explanatory variables types.

(ref:expl-var-types-caption-gitbook) Explanatory variables types, quantitative (top-left), qualitative (top-right), quantitative and qualitative without interaction (bottom-left) and quantitative and qualitative without interaction (bottom-right).

```{r, plot-quant-qual-build, echo = FALSE, cache = TRUE}

set.seed(42)

col1 <- hue_pal()(2)[1]
col2 <- hue_pal()(2)[2]

line_size <- 2

n <- 200
b0 <- 1
b1 <- 2
b2 <- 1
b12 <- -1
sigma <- .1

df1 <- tibble(x = runif(n = n, min = 0, max = 1)) %>% 
  mutate(mu = b0 + b1 * x)
df1$y <- rnorm(n = n, mean = df1$mu, sd = sigma)

df2 <- tibble(x = c(rep(0, times = n/2), rep(1, times = n/2))) %>% 
  mutate(mu = b0 + b2 * x)
df2$y <- rnorm(n = n, mean = df2$mu, sd = sigma)

df3 <- tibble(x1 = runif(n = 2*n, min = 0, max = 1),
              x2 = c(rep(0, times = n), rep(1, times = n))) %>% 
  mutate(mu = b0 + b1 * x1 + b2*x2)
df3$y <- rnorm(n = 2*n, mean = df3$mu, sd = sigma)

df4 <- tibble(x1 = runif(n = 2*n, min = 0, max = 1),
              x2 = c(rep(0, times = n), rep(1, times = n))) %>% 
  mutate(mu = b0 + b1 * x1 + b2 * x2 + b12 * x1 * x2)
df4$y <- rnorm(n = 2*n, mean = df4$mu, sd = sigma)


p_quant_qual_1 <- df1 %>% 
  ggplot(aes(x = x, y = y)) +
  geom_abline(
    intercept = b0,
    slope = b1,
    color = col1,
    size = line_size
  ) +
  geom_point(alpha = .5) +
  # labs(title = "Quantitative variable") +
  scale_x_continuous(limits = c(0, 1)) +
  easy_remove_axes(
    which = "both",
    what = "text",
    teach = FALSE
  )
  

p_quant_qual_2 <- df2 %>% 
  mutate(x = 1/2 * x + 1/4) %>% 
  ggplot(aes(x = x, y = y)) +
  # geom_abline(
  #   intercept = b0,
  #   slope = b2,
  #   color = col1
  # ) +
  geom_point(
    # data = tibble(x = c(0, 1), y = c(b0, b0 + b2)),
    data = tibble(x = c(1/4, 3/4), y = c(b0, b0 + b2)),
    mapping = aes(x = x, y = y),
    color = col1,
    size = 5#,
    # alpha = .8
  ) +
  geom_point(alpha = .5) +
  geom_point(
    # data = tibble(x = c(0, 1), y = c(b0, b0 + b2)),
    data = tibble(x = c(1/4, 3/4), y = c(b0, b0 + b2)),
    mapping = aes(x = x, y = y),
    color = col1,
    size = 5,
    alpha = .8
  ) +
  # labs(title = "Qualitative variable") +
  scale_x_continuous(limits = c(0, 1)) +
  easy_remove_axes(
    which = "both",
    what = "text",
    teach = FALSE
  )


p_quant_qual_3 <- df3 %>% 
  mutate(x2 = factor(x2)) %>% 
  ggplot(aes(x = x1, color = x2, y = y)) +
  geom_abline(
    intercept = b0,
    slope = b1,
    color = col1,
    size = line_size
  ) +
  geom_abline(
    intercept = b0 + b2,
    slope = b1,
    color = col2,
    size = line_size
  ) +
  geom_point(alpha = .5) +
  scale_color_manual(values = c(col1, col2)) +
  # labs(title = "Quantitative and qualitative variable without interaction") +
  scale_x_continuous(limits = c(0, 1)) +
  easy_remove_axes(
    which = "both",
    what = "text",
    teach = FALSE
  )


p_quant_qual_4 <- df4 %>% 
  mutate(x2 = factor(x2)) %>% 
  ggplot(aes(x = x1, color = x2, y = y)) +
  geom_abline(
    intercept = b0,
    slope = b1,
    color = col1,
    size = line_size
  ) +
  geom_abline(
    intercept = b0 + b2,
    slope = b1 + b12,
    color = col2,
    size = line_size
  ) +
  geom_point(alpha = .5) +
  scale_color_manual(values = c(col1, col2)) +
  # labs(title = "Quantitative and qualitative variable with interaction") +
  scale_x_continuous(limits = c(0, 1)) +
  easy_remove_axes(
    which = "both",
    what = "text",
    teach = FALSE
  )
```

```{r, plot-quant-qual-print, out.width = "50%", fig.align='center', fig.cap=ifelse(knitr::is_html_output(), "(ref:expl-var-types-caption-gitbook)", "(ref:expl-var-types-caption-latex)"), label="expl-var-types", echo=FALSE, fig.ncol=2, fig.subcap=c('Quantitative', 'Qualitative', 'Quantitative and qualitative \\\\ without interaction', 'Quantitative and qualitative \\\\ with interaction'), cache = TRUE}

# To align the plots in a subfigure environment
plot_grid_split <- function(..., align = "hv", axis = "tblr"){
  aligned_plots <- cowplot::align_plots(..., align = align, axis = axis)
  plots <- lapply(1:length(aligned_plots), function(x){
    cowplot::ggdraw(aligned_plots[[x]])
  })
  invisible(capture.output(plots))
}

plot_grid_split(p_quant_qual_1, p_quant_qual_2, p_quant_qual_3, p_quant_qual_4)

```

In the top-left panel, we see the effect of the quantitative variable $x$ in the model $\mu_i = \beta_0 + \beta_1 x_i$. As we can see it is a straight line. The coefficient $\beta_1$ represents the slope of the line, thus $\beta_1>0$ means that $x$ and $Y$ are positively correlated, while $\beta_1<0$ means that $x$ and $Y$ are negatively correlated. For example, if $x$ is the power of the vehicle and $Y$ the yearly number of claims, $\beta_1>0$ means that the more powerful the vehicle is, the more claims the policyholder will experience on average.

In the top-right panel, we see the effect of a qualitative binary variable $x$ in the model $\mu_i = \beta_0 + \beta_1 x_i$. The variable is encoded with values $0$ and $1$, so $\beta_1$ represents the effect of the modality $x=1$. In general, for a qualitative variable with $K$ modalities we will have $K-1$ dummy variables $x'_1, \dots, x'_{K-1}$ and the model will be $\mu_i = \beta_0 + \beta_1 x'_{i1} + \beta_2 x'_{i2} + \dots +  + \beta_{K-1} x'_{i, K-1}$. Thus, the $\beta_j$ coefficient represents the relative effect of the modality $j$ compared to the base level modality, that is the one not explicitly included in the dummy encoding. For example, if $x$ is the vehicle make, $Y$ the yearly number of claims, the base level for $x$ is 'Fiat' and the $j$^th^ modality is 'Ferrari', then $\beta_j>0$ means that Ferrari cars on average experience more claims that Fiat cars.

In general, in a multivariate model, the coefficient $\beta_j$ represents the effect of the variable $j$ given all the others. For example, in the example of Fiat and Ferrari cars, if in the model there is also the variable 'vehicle power', the coefficient $\beta_j$ corresponding to the modality 'Ferrari' represents the how more risky a Ferrari car is compared to a Fiat car with the same power. If the explanatory variables are strongly correlated, it is important to be aware of this aspect. For example, Ferrari cars are usually more powerful that Fiat cars. So, it is possible that in general Ferrari cars are more risky than Fiat cars, but comparing a Ferrari car to a Fiat with the same power, the Ferrari could be less risky. This effect is called _Simpson's paradox_ ^[Simpson's paradox, <https://en.wikipedia.org/wiki/Simpson%27s_paradox>].

In the bottom-left panel of figure \@ref(fig:expl-var-types), we see the effect of a quantitative variable $x_1$ and a qualitative binary variable $x_2$ together in the model $\mu_i = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2}$. As we can seen, the effects of $x_1$ variable in the two groups defined by $x_2$ variable are represented by two parallel straight lines. The first one is $\mu_i = \beta_0 + \beta_1 x_{i1}$ and the second is $\mu_i = \left(\beta_0 + \beta_2\right) + \beta_1 x_{i1}$. The coefficient $\beta_2$ represents the vertical distance between the two lines.

In the bottom-right panel, the interaction effect between $x_1$ and $x_2$ is included in the model. The model becomes $\mu_i = \beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \beta_3 x_{i1} x_{i2}$. That means that the effect of $x_1$ variables depends on the determination of the $x_2$ variable. In the group with $x_2=0$ the effect is represented by the line $\mu_i = \beta_0 + \beta_1 x_i$; the group with $x_2=1$ the effect is represented by the line $\mu_i = \left(\beta_0 + \beta_2\right) + \left(\beta_1 + \beta_3\right) x_{i1}$.


For quantitative variables, it is possible to consider also non linear effects in GLMs. Some examples are reported in figure \@ref(fig:expl-var-quant-effect).


(ref:expl-var-quant-effect-caption-latex) Explanatory quantitative variables effects.

(ref:expl-var-quant-effect-caption-gitbook) Explanatory quantitative variables effects, polynomial degree 2 (top-left), polynomial degree 4 (top-right), piece-wise linear (bottom-left) and piece-wise polynomial degree 2 (bottom-right).

```{r, plot-quant-effect-build, echo = FALSE, cache = TRUE}
set.seed(42)

col1 <- hue_pal()(2)[1]
col2 <- hue_pal()(2)[2]

line_size <- 2

n <- 200
b0 <- 1
b1 <- 2
b2 <- 1
b12 <- -1
sigma <- 0.05


f1 <- function(x){1.5 * (x - .3)^2 + .25}

f2 <- function(x){20*(x - .5)^4 + -4 * (x - .8)^2 - 2 * x + 2}

f3 <- function(x){
  case_when(
    x <= .25 ~ -2 * x + 1,
    x <= .75 ~ -1/2 * x + 5/8,
    TRUE ~ 1/4
  )
}

f4 <- function(x){
  case_when(
    x <= .75 ~ 1.5 * (x - .75)^2 + .2,
    TRUE ~ .2
  )
}

df <- tibble(x = runif(n = n, min = 0, max = 1)) %>% 
  mutate(
    mu1 = f1(x),
    mu2 = f2(x),
    mu3 = f3(x),
    mu4 = f4(x)
  )


df$y1 <- rnorm(n = n, mean = df$mu1, sd = sigma)
df$y2 <- rnorm(n = n, mean = df$mu2, sd = sigma)
df$y3 <- rnorm(n = n, mean = df$mu3, sd = sigma)
df$y4 <- rnorm(n = n, mean = df$mu4, sd = sigma)


p_quant_effect_1 <- df %>% 
  select(x, value = y1) %>% 
  ggplot() +
  stat_function(
    fun = f1,
    col = col1,
    size = line_size,
    xlim = c(-0.05, 1.05)
  ) +
  geom_point(aes(x = x, y = value),
             alpha = .4) +
  # scale_x_continuous(limits = c(0, 1)) +
  coord_cartesian(xlim = c(0, 1),
                  ylim = c(NA, 1.05)) +
  easy_remove_axes(
    which = "both",
    what = "text",
    teach = FALSE
  )


p_quant_effect_2 <- df %>% 
  select(x, value = y2) %>%  
  ggplot() +
  stat_function(
    fun = f2,
    col = col1,
    size = line_size,
    xlim = c(-0.05, 1.05)
  ) +
  geom_point(aes(x = x, y = value),
             alpha = .4) +
  # scale_x_continuous(limits = c(0, 1)) +
  coord_cartesian(xlim = c(0, 1),
                  ylim = c(NA, 1.05)) +
  easy_remove_axes(
    which = "both",
    what = "text",
    teach = FALSE
  )

p_quant_effect_3 <- df %>% 
  select(x, value = y3) %>%  
  ggplot() +
  # geom_vline(data = tibble(xint = c(.25, .75)),
  #            aes(xintercept = xint),
  #            linetype = "dotted") +
  geom_vline(xintercept = c(.25, .75),
             linetype = "dotted") +
  stat_function(
    fun = f3,
    col = col1,
    size = line_size,
    xlim = c(-0.05, 1.05)
  ) +
  geom_point(aes(x = x, y = value),
             alpha = .4) +
  # scale_x_continuous(limits = c(0, 1)) +
  coord_cartesian(xlim = c(0, 1),
                  ylim = c(NA, 1.05)) +
  easy_remove_axes(
    which = "both",
    what = "text",
    teach = FALSE
  )

p_quant_effect_4 <- df %>% 
  select(x, value = y4) %>%  
  ggplot() +
  geom_vline(xintercept = .75,
             linetype = "dotted") +
  stat_function(
    fun = f4,
    col = col1,
    size = line_size,
    xlim = c(-0.05, 1.05)
  ) +
  geom_point(aes(x = x, y = value),
             alpha = .4) +
  # scale_x_continuous(limits = c(0, 1)) +
  coord_cartesian(xlim = c(0, 1),
                  ylim = c(NA, 1.05)) +
  easy_remove_axes(
    which = "both",
    what = "text",
    teach = FALSE
  )
```

```{r, plot-quant-effect-print, out.width = "50%", fig.align='center', fig.cap=ifelse(knitr::is_html_output(), "(ref:expl-var-quant-effect-caption-gitbook)", "(ref:expl-var-quant-effect-caption-latex)"), label="expl-var-quant-effect", echo=FALSE, fig.ncol=2, fig.subcap=c('Polynomial degree 2', 'Polynomial degree 4', 'Piece-wise linear', 'Piece-wise polynomial degree 2'), cache = TRUE}

# # To align the plots in a subfigure environment
# plot_grid_split <- function(..., align = "hv", axis = "tblr"){
#   aligned_plots <- cowplot::align_plots(..., align = align, axis = axis)
#   plots <- lapply(1:length(aligned_plots), function(x){
#     cowplot::ggdraw(aligned_plots[[x]])
#   })
#   invisible(capture.output(plots))
# }

plot_grid_split(p_quant_effect_1, p_quant_effect_2, p_quant_effect_3, p_quant_effect_4)
```


The basic way to achieve it is by adding polynomial terms to the linear predictor. For instance, if $x$ is a quantitative variable, it is possible to add to the model the term $x^2$, obtaining the model $\mu_i = \beta_0 + \beta_1 x_{i} + \beta_2 x_i^2$. An example of model with both $x$ and $x^2$ terms is represented in top-left panel of figure \@ref(fig:expl-var-quant-effect). Adding the quadratic term, the effect graph becomes a parabola.

With the same logic, it is possible to add more power terms. In general, if we want to model $x$ with a polynomial of degree $d$, we can consider the model $\mu_i = \beta_0 + \beta_1 x_{i} + \beta_2 x_{i}^2 + \dots + \beta_d x_{i}^d$. In top-right panel of figure \@ref(fig:expl-var-quant-effect) a 4^th^ degree polynomial effect is represented. We highlight that the model is still considered linear, as the attribute "Linear" in "General Linear Model" is referred to the relation between the parameters $\beta_j$ and the linear predictor $\eta_i$ that is still linear.

Another way to model non liner effects of explanatory variables is to separate the effects by pieces. In bottom-left panel of figure \@ref(fig:expl-var-quant-effect) a case in which the $x$ effect is separated in 3 pieces is represented. As in all the pieces the effect is linear, the graph of the variable effect is a broken line. This effect can be achieved by adding to the model the terms $(x-\nu)_+$, where $(x)_+$ represents the positive part of $x$ ($(x)_+ = \max(0,x)$) and $\nu$ is the value of $x$ in the angular point. The $\nu$ values are called _knots_, If the knots are $\nu_1, \nu_2, \dots, \nu_m$, the model can be represented as $\mu_i = \beta_0 + \beta_1 x_i + \beta_2 (x_i-\nu_1)_+ + \beta_3 (x_i-\nu_2)_+ + \dots + \beta_{m+1} (x_i-\nu_m)_+$. This kind of functions are called _linear splines_ and will be further discussed in section \@ref(chap:gam). If we want the effect to be null from a certain point $\nu$, we can consider the variable $x' = \min(\nu, x)$ instead of $x$. This corresponds to aggregate to $\nu$ all the $x$ after $\nu$.

The piece-wise approach can be enhanced by also considering polynomial terms. For instance, in bottom-left panel of figure \@ref(fig:expl-var-quant-effect), the model represented is $\mu_i = \beta_0 + \left( x_i - \nu \right)_-^2$, where $(x)_-$ is the negative part of $x$ ($(x)_- = \min(0,x)$). $f(x) = (x-\nu)^2$ is a parabola with vertex in $\nu$. The fact of not adding the linear term leads to a monotonic effect made by a semi-parabola and a horizontal semi-line that starts from its vertex.

The examples represented in figures \@ref(fig:expl-var-types) and \@ref(fig:expl-var-quant-effect) are based on simulated data. That means that the linear predictor structure is known and the coefficients $\beta_0, \beta_1, \dots, \beta_J$ are known. In practice, the real model is not known and the coefficients and the structure must be estimated by the data. Thus, we can take assumptions on the structure and we can estimate the coefficients with $\hat{\beta}_0, \hat{\beta}_1, \dots, \hat{\beta}_J$. In many cases it is not so clear whether to consider or not a variable and how to consider it. For example, with the same data both bottom-left and bottom-right models could work fine. In section \@ref(chap:variable-selection) we are going to discuss some variable selection techniques for GLM.


<!--
* Qualitative variables / binary variables
  + Dummy variables
* Quantitative variables
  + Linear effects
  + Polynomial effects
    - GAM reference
  + piece wise
* Interactions
  + Manual interactions
    Problem: Scalability. Con p parametri ho choose(p, 2) possibili interazioni
 -->

<!--
Disclaimer:
Non è nota a priori la forma del predittore lineare e va stimata
Nei grafici ho sempre rappresentato la curva coi veri \beta tramite i quali i punti sono stati simulati
Nella pratica i \beta non sono noti e avremo solo gli \hat{\beta}
-->



#### Link functions and relativities

As we mentioned in \@ref(chap:linear-exp-families), GLM supports several families. In figure \@ref(fig:resp-var) the models $g(\mu_i) = \beta_0 + \beta_1 x_i$ with different response variable distributions and link functions are represented. As we can see from the plots, a linear effect on $x$ corresponds to a logistic effect when the link is logit and to an exponential effect when the link is log.


(ref:resp-var-caption-latex) Response variables and link functions.

(ref:resp-var-caption-gitbook) Response variables and link functions, Normal - identity (top-left), Binomial - logit (top-right), Poisson - log (bottom-left) and Gamma - log (bottom-right).


```{r, plot-resp-var, echo = FALSE, cache = TRUE}

set.seed(42)

col1 <- hue_pal()(2)[1]
col2 <- hue_pal()(2)[2]

line_size <- 2

n <- 200
b0 <- -2
b1 <- 4
# b2 <- 1
# b12 <- -1
sigma <- .2
alpha <- 4

df <- tibble(x = runif(n = n, min = 0, max = 1)) %>% 
  mutate(
    eta = b0 + b1 * x,
    mu1 = eta,
    mu2 = plogis(eta),
    mu3 = exp(eta),
    mu4 = exp(eta)
  )

df$y1 <- rnorm(n = n, mean = df$mu1, sd = sigma)
df$y2 <- rbinom(n = n, size = 1, prob = df$mu2)
df$y3 <- rpois(n = n, lambda = df$mu3)
df$y4 <- rgamma(n = n, shape = alpha, rate = alpha/df$mu4)


p_resp_1 <- df %>% 
  select(x, value = y1) %>% 
  ggplot() +
  geom_abline(
    intercept = b0,
    slope = b1,
    col = col1,
    size = line_size
  ) +
  geom_point(aes(x = x, y = value),
             alpha = .4) +
  # scale_x_continuous(limits = c(0, 1)) +
  coord_cartesian(xlim = c(0, 1)) +
  easy_remove_axes(
    which = "x",
    what = "text",
    teach = FALSE
  ) +
  labs(x = "x", y = "y")

p_resp_2 <- df %>% 
  select(x, value = y2) %>%  
  ggplot() +
  stat_function(
    fun = function(x){plogis(b0 + b1 * x)},
    col = col1,
    size = line_size,
    xlim = c(-0.05, 1.05)
  ) +
  geom_point(aes(x = x, y = value),
             alpha = .4) +
  # scale_x_continuous(limits = c(0, 1)) +
  coord_cartesian(xlim = c(0, 1)) +
  easy_remove_axes(
    which = "x",
    what = "text",
    teach = FALSE
  ) +
  labs(x = "x", y = "y")

p_resp_3 <- df %>% 
  select(x, value = y3) %>%  
  ggplot() +
  stat_function(
    fun = function(x){exp(b0 + b1 * x)},
    col = col1,
    size = line_size,
    xlim = c(-0.05, 1.05)
  ) +
  geom_point(aes(x = x, y = value),
             alpha = .4) +
  # scale_x_continuous(limits = c(0, 1)) +
  scale_y_continuous(breaks = c(0, 2, 4, 6, 8, 10, 12),
                     minor_breaks = 0:12) +
  coord_cartesian(xlim = c(0, 1),
                  ylim = c(0, 11)) +
  easy_remove_axes(
    which = "x",
    what = "text",
    teach = FALSE
  ) +
  labs(x = "x", y = "y")

p_resp_4 <- df %>% 
  select(x, value = y4) %>%  
  ggplot() +
  stat_function(
    fun = function(x){exp(b0 + b1 * x)},
    col = col1,
    size = line_size,
    xlim = c(-0.05, 1.05)
  ) +
  geom_point(aes(x = x, y = value),
             alpha = .4) +
  # scale_x_continuous(limits = c(0, 1)) +
  scale_y_continuous(breaks = c(0, 2, 4, 6, 8, 10, 12),
                     minor_breaks = 0:12) +
  coord_cartesian(xlim = c(0, 1),
                  ylim = c(0, 11)) +
  easy_remove_axes(
    which = "x",
    what = "text",
    teach = FALSE
  ) +
  labs(x = "x", y = "y")

```

```{r, plot-quant-effect-print, out.width = "50%", fig.align='center', fig.cap=ifelse(knitr::is_html_output(), "(ref:resp-var-caption-gitbook)", "(ref:resp-var-caption-latex)"), label="resp-var", echo=FALSE, fig.ncol=2, fig.subcap=c('Normal - identity', 'Binomial - logit', 'Poisson - log', 'Gamma - log'), cache = TRUE}

# # To align the plots in a subfigure environment
# plot_grid_split <- function(..., align = "hv", axis = "tblr"){
#   aligned_plots <- cowplot::align_plots(..., align = align, axis = axis)
#   plots <- lapply(1:length(aligned_plots), function(x){
#     cowplot::ggdraw(aligned_plots[[x]])
#   })
#   invisible(capture.output(plots))
# }

plot_grid_split(p_resp_1, p_resp_2, p_resp_3, p_resp_4,
                align = "h")
```


If $g(\mu) = \log(\mu)$, the model structure can be expressed as:
\begin{align*}
\mu_i & = e^{\beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \dots + \beta_p x_{ip}} \\
& = e^{\beta_0} \left(e^{\beta_1}\right)^{x_{i1}} \left(e^{\beta_2}\right)^{x_{i2}} \dots \left(e^{\beta_p}\right)^{x_{ip}}
\end{align*}

The term $e^{\beta_j}$ can be seen as the multiplicative factor corresponding to the variable $x_j$. If $x_j$ is a dummy variable, $e^{\beta_j}$ is the factor the expected value $\mu_i$ is multiplied by when $x_{ij}=1$. If $x_j$ is a quantitative variable, $e^{\beta_j}$ is the factor the expected value $\mu_i$ is multiplied by for every one-unit increasing of $x_{ij}$. Indeed:
$$\left(e^{\beta_j}\right)^{x_j+1} = e^{\beta_j} \left(e^{\beta_j}\right)^{x_j}$$

The fact that with a log link the relation between coefficients $\beta_0, \beta_1, \dots, \beta_p$ and expected value $\mu_i$ becomes multiplicative is particularly useful to deal with exposure $v_i$. In section \@ref(chap:exposure) we have seen that often the observations are couples (policy, accounting year), so they have different exposures $v_i$. Thus, we usually work with the number of claims occurred in the exposure period $M_i$ and we observe its realization $m_i$. The assumption we take is that:
$$M_i \sim Poisson(v_i \mu_i)$$
where $\mu_i$ is the expected value of the yearly number of claims $N_i$.

Under the GLM assumptions, we obtain
\begin{align*}
E(M_i) & = v_i \mu_i = v_i e^{\beta_0 + \beta_1 x_{i1} + \dots + \beta_p x_{ip}} \\
& = e^{\log(v_i)}e^{\beta_0 + \beta_1 x_{i1} + \dots + \beta_p x_{ip}} \\
& = e^{\beta_0 + \beta_1 x_{i1} + \dots + \beta_p x_{ip} + \log(v_i)}
\end{align*}

That means that we can model $M_1, M_2, \dots, M_n$ as response variables in a GLM with Poisson response in which the linear predictor depends on an offset additive term $\log(v_i)$.

If $g(p) = \text{logit}(p)$, the model structure can be expressed as:
\begin{align*}
\frac{p_i}{1-p_i} & = e^{\beta_0 + \beta_1 x_{i1} + \beta_2 x_{i2} + \dots + \beta_p x_{ip}} \\
& = e^{\beta_0} \left(e^{\beta_1}\right)^{x_{i1}} \left(e^{\beta_2}\right)^{x_{i2}} \dots \left(e^{\beta_p}\right)^{x_{ip}}
\end{align*}

Thus, the term $e^{\beta_j}$ can be seen as the multiplicative relativity corresponding to the variable $x_j$. However, in this case the relativity doesn't multiply directly the probability of success $p$, but it multiplies the odds of success $\frac{p}{1-p}$.


#### Variable selection {#chap:variable-selection}

One of the most challenging aspects of GLM fitting is selecting the variables and their effects by looking to observed data. In practice, we usually have many explanatory variables available but only some of them are relevant for the prediction of the response variable. Adding useless variables to the model increases the variance of the estimators of the coefficients $\tilde{\beta}_0, \tilde{\beta}_1, \dots, \tilde{\beta}_p$ and then the variance of the predictions $\tilde{\mu}_i = \tilde{\beta}_0 + \tilde{\beta}_1 x_{i1} + \dots + \tilde{\beta}_p x_{ip}$. On the other hand, being too frugal with explanatory variables could lead to wasting part of the predictive power of the available explanatory variables.

One useful tool we have to understand if an explanatory variable $x$ is relevant or not is plotting the points $(x_i, y_i)$, as we did in \@ref(fig:expl-var-types), \@ref(fig:expl-var-quant-effect) and \@ref(fig:resp-var). If there are too many observations and the plot is not easily readable, it is possible to group the points by $x$ modalities and show for each group the average of $y_i$ and a confidence interval that gives an idea on the dispersion of the observations around the average. If $x$ is a continuous variable with too many modalities, it is possible to group them into buckets. Showing the average of $y_i$ for groups of $x$ is particularly useful for Binomial and Poisson data, where the fact that $y_i$ can present few different values compromises the plot readability. An example is reported in figure \@ref(fig:var-selection). The top-left and bottom-left panels represent a case in which $x$ and $y$ are not related, while the top-right and bottom-right panels represent a case of positive correlation. From the ungrouped plot in the top-right panel the effect is not clear, while from bottom-right panel it is evident.

(ref:var-selection-caption-latex) Explanatory variable effect evaluation.

(ref:var-selection-caption-gitbook) Explanatory variable effect evaluation, No effect - ungrouped (top-left), Positive effect - ungrouped (top-right), No effect - grouped (bottom-left) and Positive effect - grouped (bottom-right).

```{r, plot-var-selection, message=FALSE, out.width = "50%", fig.align='center', fig.cap=ifelse(knitr::is_html_output(), "(ref:var-selection-caption-gitbook)", "(ref:var-selection-caption-latex)"), label="var-selection", echo=FALSE, fig.ncol=2, fig.subcap=c('No effect - ungrouped', 'Positive effect - ungrouped', 'No effect - grouped', 'Positive effect - grouped'), cache = TRUE}

set.seed(42)

col1 <- hue_pal()(2)[1]
col2 <- hue_pal()(2)[2]

line_size <- 2

n <- 1000
b0 <- -2
b1 <- 4
sigma <- 2

df <- tibble(x = rbeta(n = n, shape1 = 3, shape2 = 3)) %>% 
  mutate(
    mu1 = 0,
    mu2 = b0 + b1 * x,
    x_group = floor(10*x) / 10 + 0.05
  )

df$y1 <- rnorm(n = n, mean = df$mu1, sd = sigma)
df$y2 <- rnorm(n = n, mean = df$mu2, sd = sigma)


# Top-left plot
p_var_selection_1 <- df %>% 
  select(x, value = y1) %>% 
  ggplot() +
  geom_point(aes(x = x, y = value),
             alpha = .4) +
  coord_cartesian(xlim = c(0, 1),
                  ylim = c(-7, 7)) +
  labs(x = "x", y = "y")

p_var_selection_1


# Top-right plot
p_var_selection_2 <- df %>% 
  select(x, value = y2) %>% 
  ggplot() +
  geom_point(aes(x = x, y = value),
             alpha = .4) +
  coord_cartesian(xlim = c(0, 1),
                  ylim = c(-7, 7)) +
  labs(x = "x", y = "y")

p_var_selection_2


# Aggregate data
df_summary <- df %>%
  group_by(x_group) %>%
  summarize(
    n = n(),
    y1_mean = mean(y1),
    y1_sd = sd(y1) / sqrt(n),
    y2_mean = mean(y2),
    y2_sd = sd(y2) / sqrt(n)
  ) %>%
  mutate(
    y1_up = y1_mean + 2 * y1_sd,
    y1_down = y1_mean - 2 * y1_sd,
    y2_up = y2_mean + 2 * y2_sd,
    y2_down = y2_mean - 2 * y2_sd
  )



# Bottom-left plot
df_plot_1 <- df_summary %>%
  select(x = x_group, mean = y1_mean, down = y1_down, up = y1_up, n) %>%
  pivot_longer(cols = c("mean", "n"),
               names_to = "variable", values_to = "value") %>%
  mutate(variable = factor(variable, levels = c("mean", "n")))


p_1 <- df_plot_1 %>%
  mutate(x = factor(x)) %>%
  ggplot(aes(x = x, y = value)) +
  facet_grid(
    variable ~ .,
    scales = "free",
    labeller = labeller(variable = c("mean" = "y", "n" = "count"))
  ) +
  geom_point(data = filter(df_plot_1, variable == "mean")) +
  geom_line(data = filter(df_plot_1, variable == "mean"),
            group = 1) +
  geom_ribbon(data = filter(df_plot_1, variable == "mean"),
              aes(x = x, ymin = down, ymax = up),
              alpha = .3) +
  geom_col(data = filter(df_plot_1, variable == "n"),
           alpha = .8, col = hue_pal()(1), fill = hue_pal()(1)) +
  labs(x = "x", y = "", title = "")


p_1_ylim <- p_1 +
  coord_cartesian(ylim = c(-2.5, 2.5))

g_1 <- ggplotGrob(p_1)
g_1_ylim <- ggplotGrob(p_1_ylim)

g_1[["grobs"]][[2]] <- g_1_ylim[["grobs"]][[2]]
g_1[["grobs"]][[6]] <- g_1_ylim[["grobs"]][[6]]


g_1$heights[7] = 3*g_1$heights[7]

grid.newpage()
grid.draw(g_1)



# Bottom-right plot
df_plot_2 <- df_summary %>%
  select(x = x_group, mean = y2_mean, down = y2_down, up = y2_up, n) %>%
  pivot_longer(cols = c("mean", "n"),
               names_to = "variable", values_to = "value") %>%
  mutate(variable = factor(variable, levels = c("mean", "n")))



p_2 <- df_plot_2 %>%
  mutate(x = factor(x)) %>%
  ggplot(aes(x = x, y = value)) +
  facet_grid(
    variable ~ .,
    scales = "free",
    labeller = labeller(variable = c("mean" = "y", "n" = "count"))#,
  ) +
  geom_point(data = filter(df_plot_2, variable == "mean")) +
  geom_line(data = filter(df_plot_2, variable == "mean"),
            group = 1) +
  geom_ribbon(data = filter(df_plot_2, variable == "mean"),
              aes(x = x, ymin = down, ymax = up),
              alpha = .3) +
  geom_col(data = filter(df_plot_2, variable == "n"),
           alpha = .8, col = hue_pal()(1), fill = hue_pal()(1)) +
  labs(x = "x", y = "", title = "")

p_2_ylim <- p_2 +
  coord_cartesian(ylim = c(-2.5, 2.5))

g_2 <- ggplotGrob(p_2)
g_2_ylim <- ggplotGrob(p_2_ylim)

g_2[["grobs"]][[2]] <- g_2_ylim[["grobs"]][[2]]
g_2[["grobs"]][[6]] <- g_2_ylim[["grobs"]][[6]]


g_2$heights[7] = 3*g_2$heights[7]

grid.newpage()
grid.draw(g_2)

```

If we are dealing with a multivariate model where we already inserted the variables $x_1, \dots, x_p$ and we want to evaluate the additional information brought by $x_{p+1}$, it is possible to look at the plot $(x_{i, p+1}, r_i)$, where $r_i$ are the residuals of the model without the variable $x_{p+1}$:
$$
r_i = y_i - \hat{\mu}_i = y_i - g^{-1}\left( \hat{\beta}_0 + \hat{\beta}_1 x_{i1} + \dots + \hat{\beta}_p x_{ip} \right), \quad i\in\{1,2,\dots,n\}
$$

If the plot shows a clear trend, we will add the variable $x$ to the model, otherwise we won't.

The choice of adding or not a variable in the model can be supported by _hypothesis testing_. Given a GLM with coefficients $\beta_0, \beta_1, \dots, \beta_p$, it is possible to test if a group of coefficients $\beta_{j_1}, \beta_{j_2}, \dots, \beta_{j_s}$ is equal to zero. Formally the hypotheses tested are:
$$
\begin{cases}
H_0: & \beta_{j_k} = 0 \ \forall k \in \{1, 2, \dots, s\} \\
H_1: & \exists k: \beta_{j_k} \neq 0
\end{cases}
$$

If the hypothesis $H_0$ is accepted, the variables $x_{j_1}, x_{j_2}, \dots, x_{j_s}$ can be removed from the model; if the hypothesis $H_0$ is rejected, at least some of the variables $x_{j_1}, x_{j_2}, \dots, x_{j_s}$ should be kept in the model.

If we want to test if a quantitative variable $x_j$ has a significant effect, we can conduct the test on the single coefficient $\beta_j$. If we want to test if a qualitative variable with dummy encoding $x_{j_1}, x_{j_2}, \dots, x_{j_s}$ is significant, we can conduct the test on the coefficients $\beta_{j_1}, \beta_{j_2}, \dots, \beta_{j_s}$. For qualitative variables it is also possible to conduct a test for each level $x_{j_k}$; in this case we would test one by one if each level has an effect that is significantly different form the base level effect.

To conduct the test it is possible to use several statistics. One of them is the test based on _log likelihood ratio_. Let's indicate with $\hat{\boldsymbol{\beta}}$ the estimated coefficients from the model without any constraint and with $\hat{\boldsymbol{\beta}}^{(0)}$ the estimated coefficients with the constraints defined by $H_0$. As the space $\hat{\boldsymbol{\beta}}^{(0)}$ belongs to is a subset of the space $\hat{\boldsymbol{\beta}}$ belongs to, it results:
$$
L\left(\hat{\boldsymbol{\beta}}^{(0)}\right) \le L\left(\hat{\boldsymbol{\beta}}\right)
$$
and then:
$$
\frac{L\left(\hat{\boldsymbol{\beta}}^{(0)}\right)}{L\left(\hat{\boldsymbol{\beta}}\right)} \le 1
$$

The basic idea is that, if the variables $x_{j_1}, x_{j_2}, \dots, x_{j_s}$ have a significant effect, $L\left(\hat{\boldsymbol{\beta}}\right)$ will be much higher than $L\left(\hat{\boldsymbol{\beta}}^{(0)}\right)$ and we will reject the hypothesis $H_0$, while if the variables $x_{j_1}, x_{j_2}, \dots, x_{j_s}$ have not a significant effect, $L\left(\hat{\boldsymbol{\beta}}\right)$ will be more or less the same as $L\left(\hat{\boldsymbol{\beta}}^{(0)}\right)$ and we will accept the hypothesis $H_0$.

To perform the test, the quantity usually employed is the following:
\begin{align*}
\lambda & = -2 \log{\left( \frac{L\left(\hat{\boldsymbol{\beta}}^{(0)}\right)}{L\left(\hat{\boldsymbol{\beta}}\right)} \right)} \\
& = -2 \left[ \ell\left(\hat{\boldsymbol{\beta}}^{(0)}\right) - \ell\left(\hat{\boldsymbol{\beta}}\right) \right]
\end{align*}

If we indicate $\tilde{\lambda} = -2 \left[ \ell\left(\tilde{\boldsymbol{\beta}}^{(0)}\right) - \ell\left(\tilde{\boldsymbol{\beta}}\right) \right]$, it is possible to demonstrate that, under the hypothesis $H_0$, $\tilde{\lambda}$ has approximately chi-squared distribution with $s$ degrees of freedom:
$$
\tilde{\lambda} \dot\sim \chi^2(s)
$$

Therefore, with a significance level $\alpha$ we will reject $H_0$ when $\lambda > \chi_{s, 1-\alpha}$, where $\chi_{s, 1-\alpha}$ is the quantile of order $1-\alpha$ of the distribution $\chi^2(s)$.

The same approach can be used in general for testing hypotheses that can be expressed as $H_0: \boldsymbol{L}\boldsymbol{\beta} = \xi$, where $\boldsymbol{L}$ is a matrix $s\times(p+1)$ and $\xi\in\mathbb{R}^{p+1}$. This is particularly useful in qualitative variables to test if some of the levels have the same effect and can be then unified. For example, if $x_{j_1}$ and $x_{j_2}$ are two dummy variables that describe two levels of the same quantitative variable, we can perform the test $H_0: \beta_{j_1} = \beta_{j_2}$ in order to decide whether unifying the two levels is suitable or not.

Anyway, selecting the variables by performing hypotheses testing have some drawbacks. First of all, conducting a lot of test produce the multiple test problem. Let's consider the case in which we conduct a test of the kind $H_0: \beta_j = 0$ with a significance level $\alpha=0.05$ on many variables that have no effect on the response. On average, although the null hypotheses are always true, we will reject them once every 20 tests. That means that if we have available 100 variables, we will randomly select 5 of them, falling in _overfitting_. To fix this problem, it is possible to use the Bonferroni correction, that consist in dividing $\alpha$ by the number of test conducted to define the rejection region. But this could be a too restrictive correction that could lead to discard from the model some useful variables, falling in _underfitting_.

Moreover, hypothesis testing aim is finding whether data supports or not an hypothesis. If the aim of the model is prediction, basing variable selection on hypotheses testing could lead to a sub-optimal model.

Another method for variable selection is comparing the models by computing _information criteria_. Two information criteria commonly used are the _Akaike Information Criterion_ (AIC) and the _Bayesian Information Criterion_ (BIC):
\begin{align*}
AIC & = -2\ell(\boldsymbol{\beta}) + 2 (p+1) \\
BIC & = -2\ell(\boldsymbol{\beta}) + \log(n) (p+1)
\end{align*}

The aim of these statistics is to penalize the likelihood by adding a component that measures the complexity of the model. Among the models considered, the optimal model will be the one that minimizes the information criterion. Thus, if two models have the same likelihood, the optimal model will be the one with less parameters. If the model with more parameter has a higher likelihood, it will be chosen only if that increase in likelihood compensated the increase in complexity.

Another way to compute model predictive performance is by randomly splitting the available dataset $\mathcal{D} = \left\{ (\boldsymbol{x}_1, \omega_1, y_1), \dots,  (\boldsymbol{x}_n, \omega_n, y_n) \right\}$ into a _training set_ (or learning set) $\mathcal{D}^{\mathcal{B}}$ and a _test set_ $\mathcal{D}^{\bar{\mathcal{B}}}$, with $\mathcal{B}\subset\{1,2,\dots,n\}$ labeling the dataset $\mathcal{D}^{\mathcal{B}} = \left\{ (\boldsymbol{x}_i, \omega_i, y_i): i \in \mathcal{B} \right\} \subset \mathcal{D}$ and $\bar{\mathcal{B}} = \{1, 2, \dots, n\} \setminus \mathcal{B}$. With this split, we can fit the model on only the training set $\mathcal{D}^{\mathcal{B}}$ and assess its performance on the test set $\mathcal{D}^{\bar{\mathcal{B}}}$ by computing the deviance $D\left( \hat{\boldsymbol{\beta}}^{\mathcal{B}}, \boldsymbol{y}^{\bar{\mathcal{B}}} \right)$, where $\hat{\boldsymbol{\beta}}^{\mathcal{B}}$ is the vector of the coefficients estimated on the training set and $\boldsymbol{y}^{\bar{\mathcal{B}}}$ is the vector of the observed response variables in the test set. This way it is possible to choose the best model as the one that minimize the deviance in the test set and then fitting it with the whole dataset $\mathcal{D}$.

A limit of the train-test approach is that it could bring to overfitting in the test set. Indeed, in particular if the dataset is small, it is possible that a specific set of variables minimizes the deviance on the test set just by chance. To prevent this, it is possible to conduct a _K-fold cross validation_. This consists in randomly partitioning the dataset $\mathcal{D}$ into $K$ subsets $\mathcal{D}^{\mathcal{B}_1}, \mathcal{D}^{\mathcal{B}_2}, \dots, \mathcal{D}^{\mathcal{B}_K}$ and, for each subset $\mathcal{D}^{\mathcal{B}_k}$, performing a train-test procedure keeping $\mathcal{D}^{\setminus \mathcal{B}_k} = \mathcal{D} \setminus \mathcal{D}^{\mathcal{B}_k}$ as a training set and $\mathcal{D}^{\mathcal{B}_k}$ as a test set. For each $k$ we can compute the testing deviance $D\left( \hat{\boldsymbol{\beta}}^{\setminus \mathcal{B}_k}, \boldsymbol{y}^{\mathcal{B}_k} \right)$. We can then compute the average deviance within the $K$ subset as:
$$
D^{CV(K)} = \frac{1}{K} \sum_{k=1}^{K}{D\left( \hat{\boldsymbol{\beta}}^{\setminus \mathcal{B}_k}, \boldsymbol{y}^{\mathcal{B}_k} \right)}
$$
Thus, the best model will be the one that minimize $D^{CV(K)}$.

The higher $K$ is, the less subjected to randomness $D^{CV(K)}$ is. However, the higher $K$ is, the more computationally expensive the procedure is. A common choice for $K$ is $K=10$. If we choose $K=n$, the procedure is also called _leave-one-out cross validation_.


#### Scalability and manual fitting

One problem of GLM is that the variables selection process is not so easily scalable. Indeed, if we consider $p$ explanatory variables, even without taking into account interactions and quantitative variables transformation, there are $2^p$ possible models that can be obtained by choosing a subset of those variables. As $p$ increases, building all these models and choosing the optimal one becomes unfeasible.

One strategy to reduce the time consumption is to use a _stepwise procedure_. First of all we must choose a criterion to compare the models, such as the AIC. Then we have to choose a starting model that consider the variables subset $\mathcal{C}_0 \subset \{ 1,2,\dots,p \}$. It is possible to compare this model with all the models that can be obtained by removing one variable from $\mathcal{C}_0$ or adding to $\mathcal{C}_0$ one that is not included in it. From all these models we can compute the AIC and we will choose as $\mathcal{C}_1$ the set of variables that minimize the AIC. If none of the considered model has an AIC lower to the one obtained with the variables $\mathcal{C}_0$, the procedure ends and our final set of variables is $\mathcal{C}_0$. Otherwise, we will repeat the step with $\mathcal{C}_1$. The procedure can be iteratively repeated until we obtain a subset of variables $\mathcal{C}_f$ that can't be improved by removing or adding a variable. The model with the variables $\mathcal{C}_f$ will be our chosen one.

This procedure is much faster than computing all the $2^p$ models, but it is still not so scalable for large $p$. Moreover, in this procedure we are not taking into account the interactions and the possible transformations for the quantitative variables. This can be achieved by slightly modifying the algorithm, but it would further increase the complexity and the time consumption. Another option is starting from the result of the stepwise regression and manually choosing interactions and quantitative variables transformations by looking at plots as described in \@ref(chap:var-effects).

One characteristic of GLM is that the variables effects can be easily interpreted and the variable selection process is for large part manual. This aspect can be problematic if there are a lot of explanatory variables, but it brings some important benefits too. Indeed, the actuary can take choices on variable selection not only based on observed data, but also on his domain knowledge. For instance, the choice of selecting or not an explanatory variable can be guided also on its interpretation: if the observed effect makes sense, it can be added to the model even if it is not statistically significant and it doesn't decrease the AIC, and, on the opposite, if the observed effect is not reasonable, the actuary can choose not to insert the variable in the model even if its effect is supported by the data. So, in the actuarial practice, in the GLM fitting process there is always a subjective component that impacts on the final result. For these reason it is important for the actuary to have a deep knowledge on the phenomenon he is modeling.

An aspect that facilitates the model building and reduces the complexity of the process, even if there are many variables, is that usually the models are not built from scratch. Actuarial models are usually updated once a year, so it is also possible to start the new model by fitting on new data the final model from the year before. As the models are usually built with policies data from more than one year, the new dataset partially overlaps with the one from the previous year. However, the overlapping observations aren't identical: the new dataset will have the new settlement information and some new explanatory variables. Anyway, if the actuary is familiar with the effects of the variables in the previous models, he already knows which will probably be relevant and which don't even deserve too much attention.


<!--
* problem: effect not known
  + not known variables
  + not known shape
* approaches
  + looking to residuals (x_i, r_i)
  + hypotheses testing
    - test multipli, p-hacking
    - overfitting
  + AIC/BIC
  + Training/Test, Cross Validation
    - possibile overfitting sul test set
* manual work
  + scalability
    - choice of variables. Ho 2^p possibili modelli
    - how to model quantitative variables
    - choice of interactions. Ho choose(p, 2) possibili interazioni
    Usually actuarial models are updated once a year, so it is possible to start from models made the year before
* domain knowledge, expertise. Vantaggio dei GLM: posso metterci informazioni a priori
-->


\newpage

### GAM {#chap:gam}

In section \@ref(chap:var-effects) we have seen that sometimes quantitative variables have not a linear effect on the linear predictor. In GLM it is possible to deal with non-linear effects by adding polynomial or split-wise terms. GAMs are models based on GLM that introduce a more flexible way to deal with quantitative variables with non-linear effects.


<!--
Smooth functions
Spline cubiche
GAM assumptions
Model fitting
Model effects
-->



#### Model assumptions

In GAM, the assumptions are the same of GLM, stated in \@ref(chap:glm-assumptions), with the following advancement in the linear predictor:
$$
g(\mu_i) = \eta_i = \boldsymbol{x}_i^t \boldsymbol{\beta} + \sum_{l=1}^{q}{f_l(z_{i,l})}, \qquad i\in\{1,2,\dots,n\}
$$
where

* $\boldsymbol{x}_i$ is the vector of the variables with a linear effect as described in GLM, that also include a term $1$ that represents the intercept;
* $\boldsymbol{\beta}$ is the vector of the linear coefficients as described in GLM;
* $z_{i,1}, z_{i,2}, \dots, z_{i,q}$ are the quantitative variables with a non linear effect;
* $f_1(\cdot), f_2(\cdot), \dots, f_q(\cdot)$ are continuous functions with continuous first and second derivatives.

The functions $f_l(\cdot)$ introduce the possibility to model non-linear effects of the variables $z_l$.


#### Cubic splines {#chap:cubic-splines}

A class of functions commonly used for modeling $f_l(\cdot)$ is the class of the _cubic splines_.

```{definition, cubic-splines, name = "Cubic Splines"}
Let consider $m$ real numbers $\nu_1, \nu_2, \dots, \nu_m$, called \textit{knots}, and a function $f:[\nu_1, \nu_m] \to \mathbb{R}$ such that:
$$
f(x) = h_t(x), \qquad x\in[\nu_t, \nu_{t+1}[
$$
where, for $t = 1, 2, \dots, m-1$, $h_t(x) = \alpha_t + \vartheta_t x + \gamma_t x^2 + \delta_t x^3$. For the last index $m-1$, $f(x) = h_{m-1}(x)$ is extended to $[\nu_{m-1}, \nu_{m}]$.

$f(x)$ is a \textit{cubic spline} if it satisfies the following conditions in the internal knots $\nu_2, \nu_3, \dots, \nu_{m-1}$
\begin{equation}
\label{eq:cubic-spline-constraints}
h_{t-1}(\nu_t) = h_{t}(\nu_t), \qquad h'_{t-1}(\nu_t) = h'_{t}(\nu_t), \qquad h''_{t-1}(\nu_t) = h''_{t}(\nu_t)
\end{equation}
```

The constraints for $f(\cdot)$ make it a continuous functions with first and second derivatives continuous in $]\nu_1, \nu_m[$. It is possible to extend the cubic spline $f(\cdot)$ to an interval $[a, b] \supset [\nu_1, \nu_m]$ with linear extensions on $[a, \nu_1[$ and $]\nu_m, b]$. The so built function $f:[a,b]\to\mathbb{R}$ is called _natural cubic spline_.

In definition \@ref(def:cubic-splines) we introduced 4 parameters ($\alpha_t, \vartheta_t, \gamma_t, \delta_t$) for each of the $m-1$ intervals $[\nu_t, \nu_{t+1}[$, $t\in\{1,2,\dots,m-1\}$. So, we have $4(m-1)$ parameters. In equation \@ref(eq:cubic-spline-constraints) we introduced $3$ constraints for each of the $m-2$ knot in $\nu_2, \nu_3, \dots, \nu_{m-1}$. So the free parameters become $4(m-1) - 3(m-2) = m+2$. The linear extension on $[a, \nu_1[$ and $]\nu_m, b]$ corresponds to the constraint $f''(x)=0$ on $[a, \nu_1[ \, \cup \, ]\nu_m, b]$, thus, $h''_1(\nu_1)=0$ and $h''_m(\nu_m)=0$. Adding these two constraints, we get that the natural cubic spline $f:[a,b]\to\mathbb{R}$ has $m$ degrees of freedom.

With an approach similar to the one we used in \@ref(chap:var-effects) for split-wise effects in GLM, we can represent a cubic spline by the functions $x \mapsto \left( x-\nu_t \right)_+^3$, $t=1,2,\dots,m$.

The expression:
\begin{equation}
\label{eq:cubic-spline-decomposition}
f(x) = \alpha_0 + \vartheta_0 x + \sum_{t=1}^{m}{c_t \left( x-\nu_t \right)_+^3}, \qquad \text{with} \quad \sum_{t=1}^{m}{c_t} = 0 \quad \text{and} \quad \sum_{t=1}^{m}{c_t\nu_t} = 0
\end{equation}
gives a natural cubic spline.

The two side constraints ensure that we have a smooth linear extension above $\nu_m$. The expression \@ref(eq:cubic-spline-decomposition) presents $m+2$ parameters, thus, with the 2 side constraints, there are $m$ degrees of freedom. From this expression it is easy to show that the natural cubic splines over the interval $[a,b]$ with knots $\nu_1, \nu_2, \dots, \nu_m$ constitute a $m$-dimensional vectorial space.


#### Smoothing

If we try to fit a cubic spline on data, we find that by increasing the number of knots, the function tends to overfit data. This is due to the fact that, increasing the number of knots, we are increasing the number of parameters of the model and, thus, the variance of the parameters estimators increases. We can see this effect in figure \@ref(fig:cub-spline).

(ref:cub-spline-caption-latex) GLM with cubic splines for different numbers of knots.

(ref:cub-spline-caption-gitbook) GLM with cubic splines for different numbers of knots, $0$ knots (top-left), $3$ knots (top-right), $7$ knots (bottom-left) and $35$ knots (bottom-right).

```{r, plot-cub-spline-build, echo = FALSE, cache = TRUE}

# Read Lidar data
lidar = read.table("data/lidar.dat", header = TRUE) %>% 
  as_tibble()

lidar = lidar[sort.list(lidar$range), ]

# Standardizzo lidar$range
lidar$range = (lidar$range - mean(lidar$range)) / sd(lidar$range)



# Linear fitting

fit <- lm(logratio~., data = lidar)

p_cub_spline_1 <- lidar %>% 
  ggplot(aes(x = range, y = logratio)) +
  geom_abline(
    intercept = fit$coefficients[1],
    slope = fit$coefficients[2],
    col = col1,
    size = line_size
  ) +
  geom_point(alpha = .5)



# Cubic spline fitting

fbase = function(x, k, p) ifelse(x - k > 0, (x - k)^p, 0)
p <- 3


plot_spline_lidar <- function(dataset, knots, p = p){
  # Create basis for splines
  lidar1 <- dataset
  for (i in 1:length(knots)){
    lidar1 <- lidar1 %>% 
      mutate(b = fbase(range, knots[i], p))
    
    names(lidar1)[ncol(lidar1)] = paste("b", i, sep = "")
  }
  
  # Fit GLM
  fit <- lm(logratio~., data = lidar1)
  
  # Create fitted values
  new_lidar1 <- tibble(
    range = seq(from = min(lidar$range), to = max(lidar$range), length.out = 1e3)
  )
  for (i in 1:length(knots)){
    new_lidar1 <- new_lidar1 %>% 
      mutate(b = fbase(range, knots[i], p))
    
    names(new_lidar1)[ncol(new_lidar1)] = paste("b", i, sep = "")
  }
  
  new_lidar1$fit <- predict(fit, newdata = new_lidar1)
  
  
  p <- lidar1 %>% 
    ggplot(aes(x = range, y = logratio)) +
    geom_vline(data = tibble(knots),
               aes(xintercept = knots),
               linetype = "dotted",
               alpha = .5) +
    geom_line(
      data = new_lidar1,
      aes(x = range, y = fit),
      col = col1,
      size = line_size
    ) +
    geom_point(alpha = .5)
  
  return(p)
}


p_cub_spline_2 <- plot_spline_lidar(dataset = lidar,
                        knots = c(-1, 0, 1),
                        p = 3)

p_cub_spline_3 <- plot_spline_lidar(dataset = lidar,
                        knots = seq(from = -1.5, to = 1.5, by = .5),
                        p = 3)

p_cub_spline_4 <- plot_spline_lidar(dataset = lidar,
                        knots = seq(from = -1.7, to = 1.7, by = .1),
                        p = 3)
```


```{r, plot-cub-spline-print, out.width = "50%", fig.align='center', fig.cap=ifelse(knitr::is_html_output(), "(ref:cub-spline-caption-gitbook)", "(ref:cub-spline-caption-latex)"), label="cub-spline", echo=FALSE, fig.ncol=2, fig.subcap=c('$0$ knots', '$3$ knots', '$7$ knots', '$35$ knots'), cache = TRUE}

# # To align the plots in a subfigure environment
# plot_grid_split <- function(..., align = "hv", axis = "tblr"){
#   aligned_plots <- cowplot::align_plots(..., align = align, axis = axis)
#   plots <- lapply(1:length(aligned_plots), function(x){
#     cowplot::ggdraw(aligned_plots[[x]])
#   })
#   invisible(capture.output(plots))
# }

plot_grid_split(p_cub_spline_1, p_cub_spline_2, p_cub_spline_3, p_cub_spline_4)

```

In the top-left panel, the model fitted is just linear and it clearly doesn't follow the path made by the observed points. In the bottom-right panel, the models fitted is a spline with 35 knots and it is clearly too wiggly compared to the path made by the observed points.

A measure of the wiggliness of a function is given by the integral of its squared second derivative:
\begin{equation}
\label{eq:wiggliness}
\int_{a}^{b}{\left( f''(x) \right)^2 dx}
\end{equation}

In figure \@ref(fig:wiggliness) some examples of functions $f(x)$ and their squared second derivatives $\left(f''(x)\right)^2$ are represented. In the top panels, four functions of increasing wiggliness are represented and, in the bottom panels,  we can see their four squared second derivatives.


(ref:wiggliness-caption-latex) $\left(f''(x)\right)^2$ for functions with different wiggliness.

```{r, plot-wiggliness-print, out.width = "100%", fig.width = 10, fig.height = 5, fig.align='center', fig.cap="(ref:wiggliness-caption-latex)", label="wiggliness", echo=FALSE, cache = TRUE}

# Define expressions and compute derivatives
f2_expr <- expression(sin(2*pi*x))
f2_2_expr <- D(D(f2_expr, name = "x"), name = "x")

f3_expr <- expression(sin(3*pi*x))
f3_2_expr <- D(D(f3_expr, name = "x"), name = "x")

f4_expr <- expression(0.76*(sin(pi*x) + sin(4*pi*x)) - 0.5)
f4_2_expr <- D(D(f4_expr, name = "x"), name = "x")


# Define functions
f1 <- function(x){x - 1/2}
f1_2 <- function(x){0}

f1 <- function(x){eval(f2_expr[[1]])}
f2_2 <- function(x){eval(f2_2_expr)^2}

f2 <- function(x){eval(f3_expr[[1]])}
f3_2 <- function(x){eval(f3_2_expr)^2}

f3 <- function(x){eval(f4_expr[[1]])}
f4_2 <- function(x){eval(f4_2_expr)^2}


# Plot functions
tibble(
  x = 0:1,
  y = 0:1,
  type = c("f", "f2") %>% 
    factor(levels = c("f", "f2")),
  fun = 1:2
) %>% 
  ggplot(aes(x = x, y = y)) +
  geom_abline(aes(intercept = intercept, slope = slope),
              data = data.frame(x = 0, y = 0,
                                type = factor("f"),
                                fun = 1,
                                intercept = -.5,
                                slope = 1),
              col = col1,
              size = line_size) +
  geom_area(stat = "function", fun = f1_2,
            data = data.frame(x = 0, y = 0,
                              type = factor("f2"),
                              fun = 1),
            alpha = .5,
            col = col1,
            size = line_size / 2) +
  stat_function(fun = f1,
                data = data.frame(x = 0, y = 0,
                                  type = factor("f"),
                                  fun = 2),
                col = col1,
                size = line_size) +
  geom_area(stat = "function", fun = f2_2,
            data = data.frame(x = 0, y = 0,
                              type = factor("f2"),
                              fun = 2),
            alpha = .5,
            col = col1,
            size = line_size / 2) +
  stat_function(fun = f2,
                data = data.frame(x = 0, y = 0,
                                  type = factor("f"),
                                  fun = 3),
                col = col1,
                size = line_size) +
  geom_area(stat = "function", fun = f3_2,
            data = data.frame(x = 0, y = 0,
                              type = factor("f2"),
                              fun = 3),
            alpha = .5,
            col = col1,
            size = line_size / 2) +
  stat_function(fun = f3,
                data = data.frame(x = 0, y = 0,
                                  type = factor("f"),
                                  fun = 4),
                col = col1,
                size = line_size) +
  geom_area(stat = "function", fun = f4_2,
            data = data.frame(x = 0, y = 0,
                              type = factor("f2"),
                              fun = 4),
            alpha = .5,
            col = col1,
            size = line_size / 2) +
  facet_grid(type ~ fun,
             scales = "free_y") +
  scale_x_continuous(limits = c(0, 1)) #+
  # easy_remove_axes(
  #   which = "both",
  #   what = "text",
  #   teach = FALSE
  # )

```

As we can see from the plots, if a function $f(x)$ is linear, $\left(f''(x)\right)^2$ is null and, as the curvature of the function increases, $\left(f''(x)\right)^2$ increases. For this reason, $\left(f''(x)\right)^2$ can also be seen as a measure of how much $f(x)$ differs from a linear function.

What is done in GAM to contain this wiggliness and to prevent overfitting is taking into account a penalization based on $\left(f''(x)\right)^2$. If we have a regression problem with one explanatory variable $x$, this can be achieved by considering the minimization problem in \@ref(eq:max-lik-est-deviance) and adding a penalization term to the deviance:

\begin{equation}
\label{eq:gam-est-deviance}
\hat{f} = \argmin_{f}{\left(D(f, \boldsymbol{y}) + \lambda \int_{a}^{b}{\left( f''(x) \right)^2 dx}\right)}
\end{equation}

<!-- \begin{equation} -->
<!-- \label{eq:gam-est-deviance} -->
<!-- \boldsymbol{\hat{f}} = \argmin_{\boldsymbol{f}}{\left(D(\boldsymbol{f}, \boldsymbol{y}) + \sum_{l=1}^{s}{\lambda_l \int_{a_l}^{b_l}{\left( f''_l(z_l) \right)^2 dz_l}}\right)} -->
<!-- \end{equation} -->

In the notation of the formula \@ref(eq:gam-est-deviance) we used $f$ to indicate all the parameters of the natural cubic spline. The hyper-parameter $\lambda>0$ is called _smoothing parameter_. It measures how much we want to penalize wiggliness. If we choose $\lambda=0$ we won't penalize for $\left( f''(x) \right)^2$ and the optimization problem corresponds to the maximum likelihood. The higher $\lambda$ is, the more penalization for $\left( f''(x) \right)^2$ we introduce and the smoother the estimate $\hat{f}(x)$ will be. If $\lambda\to+\infty$, we will introduce an infinite penalization for wiggliness, so the result will have $\hat{f}''(x)=0$, thus $\hat{f}(x)$ will be linear. An example with different levels of $\lambda$ can be seen in figure \@ref(fig:gam-lambda).


(ref:gam-lambda-caption-latex) GAM estimate $\hat{f}(x)$ for different levels of $\lambda$.

(ref:gam-lambda-caption-gitbook) GAM estimate $\hat{f}(x)$ for different levels of $\lambda$, $\lambda = 0$ (top-left), $\lambda = 10$ (top-right), $\lambda = 10^3$ (bottom-left) and $\lambda = 10^6$ (bottom-right).

```{r, plot-gam-lambda-build, echo = FALSE, cache = TRUE}

# Hyperparameters
k <- 50

sp1 <- 0
sp2 <- 10
sp3 <- 1e3
sp4 <- 1e6


# Plotting function
plot_gam_lidar <- function(dataset, k, sp){
  
  # Model fitting
  
  ## Attention, the default basis is bs='tp'
  # tp: thin plate regression splines
  # cr: natural cubic regression spline
  # bs: b-slines
  
  gam1 <- gam(formula = as.formula(str_c("logratio ~ s(range, bs = 'cr', k = ", k, ")")),
              sp = sp,
              data = dataset,
              family = gaussian())
  
  
  # Predictions on new data
  new_dataset <- tibble(range = seq(from = min(dataset$range),
                                  to = max(dataset$range),
                                  length.out = 1e3))
  
  new_dataset$fit1 <- predict(gam1, newdata = new_dataset)
  
  
  # Plotting results
  p <- dataset %>% 
    ggplot(aes(x = range, y = logratio)) +
    geom_line(
      data = new_dataset,
      aes(x = range, y = fit1),
      col = col1,
      size = line_size
    ) +
    geom_point(alpha = .5) +
    easy_remove_legend(
      teach = F
    )
  
  return(p)
  
}

p_gam_lambda_1 <- plot_gam_lidar(dataset = lidar, k = k, sp = sp1)
p_gam_lambda_2 <- plot_gam_lidar(dataset = lidar, k = k, sp = sp2)
p_gam_lambda_3 <- plot_gam_lidar(dataset = lidar, k = k, sp = sp3)
p_gam_lambda_4 <- plot_gam_lidar(dataset = lidar, k = k, sp = sp4)


```

```{r, plot-gam-lambda-print, out.width = "50%", fig.align='center', fig.cap=ifelse(knitr::is_html_output(), "(ref:gam-lambda-caption-gitbook)", "(ref:gam-lambda-caption-latex)"), label="gam-lambda", echo=FALSE, fig.ncol=2, fig.subcap=c('$\\lambda = 0$', '$\\lambda = 10$', '$\\lambda = 10^3$', '$\\lambda = 10^6$'), cache = TRUE}

plot_grid_split(p_gam_lambda_1, p_gam_lambda_2, p_gam_lambda_3, p_gam_lambda_4)

```

All the models has been fitted with $m = 50$ knots. As we can see, with $\lambda = 0$ we are clearly overfitting observations, while with $\lambda = 10^6$ we are clearly underfitting them.

As soon as the number of knots $m$ is large enough, the exact number $m$ and the positioning of the knots $\nu_1, \nu_2, \dots, \nu_m$ is not important. If the function is flexible enough, the tuning of the curve is done by just tuning $\lambda$. It is possible to use as many knots as the determinations of $x$ are, but it could be too computationally expensive. A possible choice is to fix a number of knots $m$ and positioning $\nu_1, \nu_2, \dots, \nu_m$ on empirical quantiles of the observed $x$ or equally spaced in the range of $x$. In our example, $m=50$ knots seems to be large enough.

In general, if we have $q$ quantitative explanatory variables that we want to fit with splines, the formula \@ref(eq:gam-est-deviance) becomes:
\begin{equation}
\label{eq:gam-est-deviance-multi}
\boldsymbol{\hat{f}} = \argmin_{\boldsymbol{f}}
{\left(
  D(\boldsymbol{f}, \boldsymbol{y})
    + \sum_{l=1}^{q}{
      \lambda_l \int_{a_l}^{b_l}{\left( f_l''(x_l) \right)^2 dx}
    }
\right)} 
\end{equation}
where $\boldsymbol{f} = \left( f_1, f_2,\dots,f_q \right)$.

In this context, we have to tune a vector of $q$ smoothing parameters:
$$\boldsymbol{\lambda} = \left( \lambda_1, \lambda_2, \dots, \lambda_q \right)$$


#### Choice of the smoothing parameters

As described, the selection of the $x_l$ effect consists just in finding the optimal parameter $\lambda_l$. The technique commonly used in machine learning for hyper-parameter tuning is the _Cross Validation_.

For a set $\Lambda$ of values of $\boldsymbol{\lambda}$ we can perform a K-fold cross validation as described in \@ref(chap:variable-selection) and, for each $\boldsymbol{\lambda}\in\Lambda$, we can compute the average test deviance:
$$
D^{CV(K)}_{\boldsymbol{\lambda}} =
\frac{1}{K} \sum_{k=1}^{K}{
D\left(
\boldsymbol{\hat{f}}_{\boldsymbol{\lambda}}^{\setminus \mathcal{B}_k}, \boldsymbol{y}^{\mathcal{B}_k}
\right)
}
$$
At this point, we will choose the hyper-parameter vector that minimizes the cross-validation deviance:
$$
\hat{\boldsymbol{\lambda}} = \argmin_{\boldsymbol{\lambda}\in\Lambda}{D^{CV(K)}_{\boldsymbol{\lambda}}}
$$

In particular if $q$ is big, this procedure can be too computationally expensive. Two alternatives are the _Generalized Cross Validation_ (GCV) and the _Un-Biased Risk Estimator_ (UBRE). The idea behind these approaches is to estimate the test set deviance by just computing the training set deviance and applying to it a correction that penalizes for the complexity of the model, as it is done in AIC and BIC, described in section \@ref(chap:variable-selection).

GCV and UBRE formulas are based on the fact that GAMs with identity link and Normal response are _linear smoothers_, i.e. $\boldsymbol{\hat{\mu}}$ can be expressed as:
\begin{equation}
\label{eq:linear-smoother}
\boldsymbol{\hat{\mu}} = L \boldsymbol{y}
\end{equation}
where $L$ is a $n\times n$ matrix that depends on the design matrix $\boldsymbol{X}$ and the hyper-parameters. $L$ is called _smoothing matrix_. In general, if the link is not identity and the response is not Normal, GAM is not a linear smoother, but the formula \@ref(eq:linear-smoother) still holds up with a local approximation.

It can be proven that the trace of $L$ measures the flexibility of the function. Indeed, in Linear Model $L=\left( X^tX \right)^{-1}X^t$ and $\text{tr}(L) = \text{tr}\left( \left( X^tX \right)^{-1}X^t \right) = p+1$, that is the number of _degrees of freedom_ of the model. For this reason $\text{tr}(L)$ is also called number of _effective degrees of freedom_ of the model. In GAM, as the smoothing parameter $\lambda$ increases, the flexibility of the model decreases and $\text{tr}(L)$ decreases.

For linear smoothers it can be proved that the _leave one out cross validation_ is:
$$
D^{CV(n)} = \frac{1}{n} \sum_{i=1}^{n}{\left( \frac{y_i - \hat{\mu}_i}{1 - L_{ii}} \right)^2}
$$
where $L_{ii}$ is the $i$^th^ element of the diagonal of the smoothing matrix $L$.

This formula is particularly convenient because it requires just the fit with the whole dataset and not one fit for each fold. Indeed, in the formula the quantities that must be computed are $\mu_i$ and $L_{ii}$, that both depend on the model fitted with the whole dataset.

This formula can be further simplified by replacing the values $L_{ii}$ with their average $\frac{\text{tr}(L)}{n}$. This way we get the GCV.
\begin{equation}
\label{eq:gcv}
GCV = \frac{1}{n} \sum_{i=1}^{n}{\left( \frac{y_i - \hat{\mu}_i}{1 - \frac{\text{tr}(L)}{n}} \right)^2}
\end{equation}

As for K-fold cross validation we can compute the GCV for different values of $\boldsymbol{\lambda} \in \Lambda$ and choose the value $\boldsymbol{\hat{\lambda}}$ that minimizes the GCV.

The formula \@ref(eq:gcv) can be expressed as:
\begin{align}
\nonumber
GCV & = \frac{1}{n} \sum_{i=1}^{n}{\left( \frac{y_i - \hat{\mu}_i}{1 - \frac{\text{tr}(L)}{n}} \right)^2} \\
\nonumber
& = \left( \frac{n}{n - \text{tr}(L)} \right)^2 \underbrace{\frac{\sum_{i=1}^{n}{\left( y_i - \hat{\mu}_i \right)^2}}{n}}_{=D(\boldsymbol{\hat{f}},\boldsymbol{y})} \\
\label{eq:gcv-gam}
& = \left( \frac{n}{n - \text{tr}(L)} \right)^2 D(\boldsymbol{\hat{f}},\boldsymbol{y})
\end{align}

The expression \@ref(eq:gcv-gam) generalizes the GCV to al the GAMs, also in the case in which the link is not identity and the response is not Normal.

To select the best value of $\boldsymbol{\lambda}$, we can perform a similar procedure using the UBRE in place of the GCV. The UBRE is defined as:
$$
UBRE = \frac{1}{n} D(\boldsymbol{\hat{f}}, \boldsymbol{y}) - \phi + \frac{2}{n} \text{tr}(L)\phi 
$$

Using the UBRE instead the GCV is preferred when $\phi$ is known, such as in Poisson regression case, in which $\phi=1$.


#### Why cubic splines

In section \@ref(chap:cubic-splines) we said that _cubic splines_ are commonly used for modeling $f(\cdot)$ in GAMs. This choice comes from the following theorem.

```{theorem, th-splines-property, name = "Spline property"}
Given the knots $\nu_1, \nu_2, \dots, \nu_m$ and the values $y_1, y_1, \dots, y_m$, for any $a\le\nu_1$ and $b\ge\nu_m$, only one natural cubic spline $s(\cdot)$, such that $s(\nu_k)=y_k, \ k\in \{1, \dots, m\}$, exists.

Moreover, given $f(\cdot)$ a function two times differentiable with continuity, such that $f(\nu_k)=y_k, \ k\in \{1, \dots, m\}$, then, for any $a\le\nu_1$ and $b\ge\nu_m$, it results
$$
\int_a^b{\left( s''(x)\right)^2 dx} \le \int_a^b{\left( f''(x)\right)^2 dx}
$$
```
One consequence of this theorem is that, within all the continuous function $f(\cdot)$ with continuous first and second derivatives, the one that minimize the optimization problem \@ref(eq:gam-est-deviance) is always a natural cubic splines.

Let's consider the determinations $x_1^* < x_2^* < \dots < x_m^*$ of the variable $x$. If $f(\cdot)$ is a continuous function with continuous first and second derivatives, for the theorem \@ref(thm:th-splines-property), there exists only one natural cubic spline $s(\cdot)$ such that $s(x_k^*) = f(x_k^*), \ k\in \{1, \dots, m\}$. As, $s(x_i)=f(x_i) \ \forall i \in \mathcal{D}$, it results that $D(s, \boldsymbol{y}) = D(f, \boldsymbol{y})$. As $D(s, \boldsymbol{y}) = D(f, \boldsymbol{y})$ and $\int_a^b{\left( s''(x)\right)^2 dx} \le \int_a^b{\left( f''(x)\right)^2 dx}$, it results that, for any given $\lambda$:
$$
D(s, \boldsymbol{y}) + \lambda \int_{a}^{b}{\left( s''(x) \right)^2 dx}
\ \le \ 
D(f, \boldsymbol{y}) + \lambda \int_{a}^{b}{\left( f''(x) \right)^2 dx}
$$

For this reason, if the aim of the model estimation is to minimize \@ref(eq:gam-est-deviance), for choosing $f$ we can just consider the class of the natural cubic splines.



#### Other basis

In section \@ref(chap:cubic-splines) we said that natural cubic splines on knots $\nu_1, \dots, \nu_m$ constitute a $m$-dimensional vector space and that a possible basis decomposition is \@ref(eq:cubic-spline-decomposition).

Another usual basis is the _B-spline_ basis. B-splines are functions defined recursively as follows.

```{definition, b-splines, name = "B-splines"}
For $k\in\{1,2,\dots,m-1\}$:
$$
B_{0,k}(x) = 
\begin{cases}
1: & \nu_k < x < \nu_{k+1} \\
0: & \text{otherwise}
\end{cases}
$$

For $j \ge 0$ and $k\in\{1,2,\dots,m+j\}$:
$$
B_{j+1,k}(x) = 
\frac{x-\nu_{k-j-1}}{\nu_{k}-\nu_{k-j-1}} B_{j,k-1}(x)
+ \frac{\nu_{k+1}-x}{\nu_{k+1}-\nu_{k-j}} B_{j,k}(x)
$$
```

In figure \@ref(fig:b-splines-plot) some B-splines of different degrees are represented. 

(ref:plot-b-splines-caption-latex) B-splines with different degrees.

(ref:plot-b-splines-caption-gitbook) B-splines with different degrees, degree $1$ (left), degree $2$ (center), degree $3$ (right)


```{r, plot-b-splines-build, echo = FALSE, cache = TRUE}

knots <- c(1,2,3)
x <- seq(from = 0, to = 4, by = .01)

base_1 = bs(x, knots = knots, degree = 1, intercept = TRUE)

p_b_splines_1 <- cbind(x, base_1) %>% 
  as_tibble() %>% 
  pivot_longer(
    cols = -x,
    names_to = "base",
    values_to = "value"
  ) %>% 
  ggplot(aes(x = x, y = value, color = base)) +
  geom_line() +
  easy_remove_axes(
    which = "y",
    what = "text",
    teach = FALSE
  ) +
  easy_remove_legend() +
  scale_x_continuous(
    breaks = 0:4,
    labels = c(
      expression(nu[1]),
      expression(nu[2]),
      expression(nu[3]),
      expression(nu[4]),
      expression(nu[5])
    )
  ) +
  labs(x = "x", y = "y")


base_2 = bs(x, knots = knots, degree = 2, intercept = TRUE)

p_b_splines_2 <- cbind(x, base_2) %>% 
  as_tibble() %>% 
  pivot_longer(
    cols = -x,
    names_to = "base",
    values_to = "value"
  ) %>% 
  ggplot(aes(x = x, y = value, color = base)) +
  geom_line() +
  easy_remove_axes(
    which = "y",
    what = "text",
    teach = FALSE
  ) +
  easy_remove_legend() +
  scale_x_continuous(
    breaks = 0:4,
    labels = c(
      expression(nu[1]),
      expression(nu[2]),
      expression(nu[3]),
      expression(nu[4]),
      expression(nu[5])
    )
  ) +
  labs(x = "x", y = "y")


base_3 = bs(x, knots = knots, degree = 3, intercept = TRUE)

p_b_splines_3 <- cbind(x, base_3) %>% 
  as_tibble() %>% 
  pivot_longer(
    cols = -x,
    names_to = "base",
    values_to = "value"
  ) %>% 
  ggplot(aes(x = x, y = value, color = base)) +
  geom_line() +
  easy_remove_axes(
    which = "y",
    what = "text",
    teach = FALSE
  ) +
  easy_remove_legend() +
  scale_x_continuous(
    breaks = 0:4,
    labels = c(
      expression(nu[1]),
      expression(nu[2]),
      expression(nu[3]),
      expression(nu[4]),
      expression(nu[5])
    )
  ) +
  labs(x = "x", y = "y")

```


```{r, plot-b-splines-print, out.width = "32%", fig.align='center', fig.cap = ifelse(knitr::is_html_output(), "(ref:plot-b-splines-caption-gitbook)", "(ref:plot-b-splines-caption-latex)"), label = "b-splines-plot", echo = FALSE, fig.ncol = 3, fig.subcap = c('degree $1$', 'degree $2$', 'degree $3$'), cache = TRUE}

plot_grid_split(p_b_splines_1, p_b_splines_2, p_b_splines_3)

```

It can be proven that \@ref(def:b-splines) defines functions $B_{j,k}(x)$ that, given $j$, are splines of degree $j$. Moreover, $B_{j,1}, \dots, B_{j,m+j-1}$ constitute a basis of the vector space of the splines of degree $j$ on the knots $\nu_1, \dots, \nu_m$. In particular, $B_{3,1}, \dots, B_{j,m+2}$ constitute a basis of the vector space of the splines of degree $3$. Therefore, if $s(x)$ is third degree spline on the knots $\nu_1, \dots, \nu_m$, it can be expressed as a linear combination of $B_{3,1}, \dots, B_{3,m+2}$:
$$
s(x) = \sum_{k=1}^{m+2}{\beta_{k}B_{3,k}(x)}
$$

B-splines are preferred compared to truncated polynomial as they are less correlated and lead to more stable and less computationally expensive estimates.

<!--
Da scrivere
- why splines
- other basis
- calcoli a partire da integrale
-->


#### GAM extensions

As in GLM, in GAM we can consider interactions between a variable with non-linear effect $x_{l_2}$ and another variable $x_{l_1}$. This can be achieved by adding to the linear predictor a term such as:
$$
x_{l_1} f(x_{l_2})
$$
This is particularly useful when $x_{l_1}$ is a binary variable and we want to fit two different curves for $x_{l_2}$ in the case $x_{l_1}=0$ and in the case $x_{l_1}=1$.

If we want to consider a more complex interaction between two quantitative variables with non-linear effect, GAM can be extended by considering non-parametrical interactions and modeling them with two-dimensional splines, such as:
$$
f(x_{l_1}, x_{l_2})
$$
In this case, instead of fitting a curve on $(x_l, y)$, we will fit a flexible surface on $(x_{l_1}, x_{l_2}, y)$. This approach can be adopted also for modeling geographical data, in which $x_{l_1}, x_{l_2}$ are coordinates on the map, such as longitude and latitude.

<!--
Da scrivere
- Generalizzare a più variabili
- Altre splines (interazioni)
- GCV
-->


#### Some considerations on GAM

As we have seen in this chapter, GAMs are flexible tools for fitting quantitative variables with non-linear effects.

One big advantage of GAM is that they are based on the same assumptions of GLM, except for the non-linearity of the components $f(x_{l})$. The connection with GLM leads to highly interpretable results. Indeed, as we do in GLM, in GAM we can easily observe the marginal effect of a variable $x_l$ on the response $y$ just by plotting the graph $\left(x_l, f(x_l)\right)$, while the interactions between variables are added manually so we have a full control of them.

Another big advantage is that GAM not only provides a flexible tool that produces interpretable results, but this tool works almost automatically. Indeed, while in GLM, when we have to fit a non-linear effect to a quantitative variable $x_l$, we have to perform a manual process of wise splitting and polynomial fitting on the range of $x_l$, in GAM we do not have to explicity specify the shape of $f(x_l)$ and everything is done by the algorithm.

This higher flexibility and automation comes at the cost of introducing more complexity in the model. Indeed, in a GAM there are much more parameters than in a GLM and this leads to a more computationally expensive fitting. Anyway, this higher complexity produces an higher machine time but significantly reduces the human time that in GLM would be needed for manual fitting.

<!--
- flessibile
- basato su GLM. Within the GLM framework. Interpretabile. Le interazioni sono inserite manualmente
- automatico. Non devo fare lavoro manuale con splitwise e polinomi vari
- semiparametrico. More complexity. Machine time
-->

\newpage

### Shrinkage estimators for GLM

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus id mauris interdum, malesuada ante eu, tempus lacus. Aliquam blandit tortor a velit ultricies, eget pharetra nulla egestas. Suspendisse pellentesque finibus est, vitae ullamcorper magna convallis ut. Nulla a lectus in ligula iaculis convallis. Pellentesque tortor mauris, tempor nec dictum et, facilisis sit amet dolor. Mauris nibh quam, molestie non ex quis, hendrerit dignissim nulla. Aliquam sit amet dui at diam vestibulum malesuada a id lacus. Phasellus viverra orci vitae sem pretium, eu consequat libero euismod.


#### Ridge Regression

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus id mauris interdum, malesuada ante eu, tempus lacus. Aliquam blandit tortor a velit ultricies, eget pharetra nulla egestas. Suspendisse pellentesque finibus est, vitae ullamcorper magna convallis ut. Nulla a lectus in ligula iaculis convallis. Pellentesque tortor mauris, tempor nec dictum et, facilisis sit amet dolor. Mauris nibh quam, molestie non ex quis, hendrerit dignissim nulla. Aliquam sit amet dui at diam vestibulum malesuada a id lacus. Phasellus viverra orci vitae sem pretium, eu consequat libero euismod.


#### LASSO Regression

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus id mauris interdum, malesuada ante eu, tempus lacus. Aliquam blandit tortor a velit ultricies, eget pharetra nulla egestas. Suspendisse pellentesque finibus est, vitae ullamcorper magna convallis ut. Nulla a lectus in ligula iaculis convallis. Pellentesque tortor mauris, tempor nec dictum et, facilisis sit amet dolor. Mauris nibh quam, molestie non ex quis, hendrerit dignissim nulla. Aliquam sit amet dui at diam vestibulum malesuada a id lacus. Phasellus viverra orci vitae sem pretium, eu consequat libero euismod.


#### Elastic Net

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus id mauris interdum, malesuada ante eu, tempus lacus. Aliquam blandit tortor a velit ultricies, eget pharetra nulla egestas. Suspendisse pellentesque finibus est, vitae ullamcorper magna convallis ut. Nulla a lectus in ligula iaculis convallis. Pellentesque tortor mauris, tempor nec dictum et, facilisis sit amet dolor. Mauris nibh quam, molestie non ex quis, hendrerit dignissim nulla. Aliquam sit amet dui at diam vestibulum malesuada a id lacus. Phasellus viverra orci vitae sem pretium, eu consequat libero euismod.

Cras suscipit aliquam consequat. Quisque sodales lacus ac erat malesuada, eu laoreet enim vestibulum. Sed id ante id ligula auctor ullamcorper. Sed luctus rutrum mollis. Vestibulum sed ultrices quam. Duis id orci ut enim elementum maximus id quis justo. Pellentesque rutrum ligula in aliquam rhoncus. Integer suscipit nisl at mi efficitur interdum. Aenean et orci elit.

Nam ultricies est et iaculis tempus. Quisque leo lorem, sagittis et ligula a, blandit mattis velit. Phasellus pretium, orci et semper finibus, dui nulla tempor nisl, vel vehicula magna diam nec sem. Praesent finibus commodo enim non laoreet. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur ut pellentesque purus. Proin hendrerit, odio vel sodales porta, ex lorem feugiat sem, non fringilla libero ex ac ligula. Quisque facilisis eros at suscipit rhoncus.


#### Bayesian GLM

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus id mauris interdum, malesuada ante eu, tempus lacus. Aliquam blandit tortor a velit ultricies, eget pharetra nulla egestas. Suspendisse pellentesque finibus est, vitae ullamcorper magna convallis ut. Nulla a lectus in ligula iaculis convallis. Pellentesque tortor mauris, tempor nec dictum et, facilisis sit amet dolor. Mauris nibh quam, molestie non ex quis, hendrerit dignissim nulla. Aliquam sit amet dui at diam vestibulum malesuada a id lacus. Phasellus viverra orci vitae sem pretium, eu consequat libero euismod.

Cras suscipit aliquam consequat. Quisque sodales lacus ac erat malesuada, eu laoreet enim vestibulum. Sed id ante id ligula auctor ullamcorper. Sed luctus rutrum mollis. Vestibulum sed ultrices quam. Duis id orci ut enim elementum maximus id quis justo. Pellentesque rutrum ligula in aliquam rhoncus. Integer suscipit nisl at mi efficitur interdum. Aenean et orci elit.

Nam ultricies est et iaculis tempus. Quisque leo lorem, sagittis et ligula a, blandit mattis velit. Phasellus pretium, orci et semper finibus, dui nulla tempor nisl, vel vehicula magna diam nec sem. Praesent finibus commodo enim non laoreet. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur ut pellentesque purus. Proin hendrerit, odio vel sodales porta, ex lorem feugiat sem, non fringilla libero ex ac ligula. Quisque facilisis eros at suscipit rhoncus.


\newpage

### GBM

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus id mauris interdum, malesuada ante eu, tempus lacus. Aliquam blandit tortor a velit ultricies, eget pharetra nulla egestas. Suspendisse pellentesque finibus est, vitae ullamcorper magna convallis ut. Nulla a lectus in ligula iaculis convallis. Pellentesque tortor mauris, tempor nec dictum et, facilisis sit amet dolor. Mauris nibh quam, molestie non ex quis, hendrerit dignissim nulla. Aliquam sit amet dui at diam vestibulum malesuada a id lacus. Phasellus viverra orci vitae sem pretium, eu consequat libero euismod.

Cras suscipit aliquam consequat. Quisque sodales lacus ac erat malesuada, eu laoreet enim vestibulum. Sed id ante id ligula auctor ullamcorper. Sed luctus rutrum mollis. Vestibulum sed ultrices quam. Duis id orci ut enim elementum maximus id quis justo. Pellentesque rutrum ligula in aliquam rhoncus. Integer suscipit nisl at mi efficitur interdum. Aenean et orci elit.

Nam ultricies est et iaculis tempus. Quisque leo lorem, sagittis et ligula a, blandit mattis velit. Phasellus pretium, orci et semper finibus, dui nulla tempor nisl, vel vehicula magna diam nec sem. Praesent finibus commodo enim non laoreet. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur ut pellentesque purus. Proin hendrerit, odio vel sodales porta, ex lorem feugiat sem, non fringilla libero ex ac ligula. Quisque facilisis eros at suscipit rhoncus.



## Considerations of models

### Model comparison {#chap:model-comparison}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus id mauris interdum, malesuada ante eu, tempus lacus. Aliquam blandit tortor a velit ultricies, eget pharetra nulla egestas. Suspendisse pellentesque finibus est, vitae ullamcorper magna convallis ut. Nulla a lectus in ligula iaculis convallis. Pellentesque tortor mauris, tempor nec dictum et, facilisis sit amet dolor. Mauris nibh quam, molestie non ex quis, hendrerit dignissim nulla. Aliquam sit amet dui at diam vestibulum malesuada a id lacus. Phasellus viverra orci vitae sem pretium, eu consequat libero euismod.

Cras suscipit aliquam consequat. Quisque sodales lacus ac erat malesuada, eu laoreet enim vestibulum. Sed id ante id ligula auctor ullamcorper. Sed luctus rutrum mollis. Vestibulum sed ultrices quam. Duis id orci ut enim elementum maximus id quis justo. Pellentesque rutrum ligula in aliquam rhoncus. Integer suscipit nisl at mi efficitur interdum. Aenean et orci elit.

Nam ultricies est et iaculis tempus. Quisque leo lorem, sagittis et ligula a, blandit mattis velit. Phasellus pretium, orci et semper finibus, dui nulla tempor nisl, vel vehicula magna diam nec sem. Praesent finibus commodo enim non laoreet. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur ut pellentesque purus. Proin hendrerit, odio vel sodales porta, ex lorem feugiat sem, non fringilla libero ex ac ligula. Quisque facilisis eros at suscipit rhoncus.



### The actuary importance {#chap:actuary-importance}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus id mauris interdum, malesuada ante eu, tempus lacus. Aliquam blandit tortor a velit ultricies, eget pharetra nulla egestas. Suspendisse pellentesque finibus est, vitae ullamcorper magna convallis ut. Nulla a lectus in ligula iaculis convallis. Pellentesque tortor mauris, tempor nec dictum et, facilisis sit amet dolor. Mauris nibh quam, molestie non ex quis, hendrerit dignissim nulla. Aliquam sit amet dui at diam vestibulum malesuada a id lacus. Phasellus viverra orci vitae sem pretium, eu consequat libero euismod.

Cras suscipit aliquam consequat. Quisque sodales lacus ac erat malesuada, eu laoreet enim vestibulum. Sed id ante id ligula auctor ullamcorper. Sed luctus rutrum mollis. Vestibulum sed ultrices quam. Duis id orci ut enim elementum maximus id quis justo. Pellentesque rutrum ligula in aliquam rhoncus. Integer suscipit nisl at mi efficitur interdum. Aenean et orci elit.

Nam ultricies est et iaculis tempus. Quisque leo lorem, sagittis et ligula a, blandit mattis velit. Phasellus pretium, orci et semper finibus, dui nulla tempor nisl, vel vehicula magna diam nec sem. Praesent finibus commodo enim non laoreet. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur ut pellentesque purus. Proin hendrerit, odio vel sodales porta, ex lorem feugiat sem, non fringilla libero ex ac ligula. Quisque facilisis eros at suscipit rhoncus.



## Implementation {#chap:implementation}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vivamus id mauris interdum, malesuada ante eu, tempus lacus. Aliquam blandit tortor a velit ultricies, eget pharetra nulla egestas. Suspendisse pellentesque finibus est, vitae ullamcorper magna convallis ut. Nulla a lectus in ligula iaculis convallis. Pellentesque tortor mauris, tempor nec dictum et, facilisis sit amet dolor. Mauris nibh quam, molestie non ex quis, hendrerit dignissim nulla. Aliquam sit amet dui at diam vestibulum malesuada a id lacus. Phasellus viverra orci vitae sem pretium, eu consequat libero euismod.

Cras suscipit aliquam consequat. Quisque sodales lacus ac erat malesuada, eu laoreet enim vestibulum. Sed id ante id ligula auctor ullamcorper. Sed luctus rutrum mollis. Vestibulum sed ultrices quam. Duis id orci ut enim elementum maximus id quis justo. Pellentesque rutrum ligula in aliquam rhoncus. Integer suscipit nisl at mi efficitur interdum. Aenean et orci elit.

Nam ultricies est et iaculis tempus. Quisque leo lorem, sagittis et ligula a, blandit mattis velit. Phasellus pretium, orci et semper finibus, dui nulla tempor nisl, vel vehicula magna diam nec sem. Praesent finibus commodo enim non laoreet. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Curabitur ut pellentesque purus. Proin hendrerit, odio vel sodales porta, ex lorem feugiat sem, non fringilla libero ex ac ligula. Quisque facilisis eros at suscipit rhoncus.


<!--
Modelli più complessi: importanza dell'ottimizzazione computazionale
-->





<!-- \titlespacing{\chapter}{0pt}{0pt}{35pt} -->

